{
  
    
        "post0": {
            "title": "Evaluating Color Blindness Simulations",
            "content": "Generated Ishihara-like plates to evaluate the kind and severity of CVD . It is possible to generate Ishihara-like plates for a given deficiency and severity factor. The main idea is to pick a confusion segment in the LMS space, and generate an Ishihara-like image by using one end of the segment as the background color and the other end as the foreground color (a single-digit number). On top of that lower degrees of severity can be tested by making the segment shorter, effectively reducing the distance between the colors along the confusion line. This makes it harder and harder to differentiate for someone with anomalous trichromacy. . By looking at these generated plates it becomes possible to self-evaluate the kind of deficiency by checking in which plate the numbers are the harder to read. For example I can read all the numbers in the tritan plate, most numbers in the deutan plate (but not all), and barely any in the protan plate. This confirms that I am a protan. . Then the severity can be evaluated by looking at plates generated with decreasing severity and checking at which value it becomes impossible to see any number. For me that&#39;s around 0.8 for the protan plate. . # This cell defines all our imports and a few utilities import daltonlens.generate as generate import daltonlens.simulate as simulate import numpy as np import plotly.express as px import plotly.graph_objs as go from plotly.subplots import make_subplots # Utility for plotly imshow hide_image_axes = dict(yaxis_visible=False, yaxis_showticklabels=False, xaxis_visible=False, xaxis_showticklabels=False, margin=dict(l=0, r=0, b=0, t=0)) def showAnimatedImages(title, deficiency): images = [] for severity in np.arange(1.0, 0.19, -0.1): im = generate.ishihara_plate(deficiency, severity, f&quot;Severity {severity:.1f}&quot;) images.append (im) images = np.stack(images, axis=0) fig = px.imshow(images, height=704*1.4, animation_frame=0, title=title).update_layout(hide_image_axes).update_layout(margin=None) fig.show() showAnimatedImages(&quot;Protanopia / protanomaly&quot;, simulate.Deficiency.PROTAN) showAnimatedImages(&quot;Deuteranopia / deuteranomaly&quot;, simulate.Deficiency.DEUTAN) showAnimatedImages(&quot;Tritanopia / tratanomaly&quot;, simulate.Deficiency.TRITAN) . . .",
            "url": "http://daltonlens.org/evaluating-cvd-simulation/",
            "relUrl": "/evaluating-cvd-simulation/",
            "date": " • Oct 30, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Understanding LMS-based Color Blindness Simulations",
            "content": "Introduction . This post is a followup to our Review of Open Source Color Blindness Simulations and assumes that you are familiar with color vision deficiencies (CVD) simulation. The goal of this post is to dive into how these methods actually work. To visualize and play with the models interactively this page is actually generated from a Jupyter notebook (using fastpages) and can be run in e.g. Google colab to play with it. . The interactive 3D plots make it hard to read on mobile, a large screen is recommended. . (Brettel &amp; Mollon, 1997), (Viénot, Brettel, &amp; Mollon, 1999) and (Machado, Oliveira, &amp; Fernandes, 2009) all rely on the same low-level principles to simulate CVD. For all of them the final code will basically just apply a sRGB/gamma function, one or two 3x3 matrices, undo the gamma, and call it a day. But we&#39;re going to analyze that pipeline and try to understand how to compute those matrices and get a sense of what they do. . The Machado 2009 method is actually a bit more involved as it uses a second stage of modeling (opponent-color theory), so we will not cover it here and only focus on Viénot 1999 and Brettel 1997. Both focus on full dichromacy, so we&#39;ll start with that. The extension to anomalous trichromacy will be discussed in section What about anomalous trichromacy?, and it&#39;s worth noting that Machado 2009 has similar results for dichromacy anyway. . Let&#39;s first get an overview of the process. Protanopes, deuteranopes and tritanopes respectively lack the L, M, and S cone cells. Thus a natural approach to simulate dichromacy is to go to the LMS color-space and somehow remove the component coming from the missing cone cells. The good news is that going from an RGB color space to LMS can be done with a linear transformation (matrix multiplication). But as usual there are many ways to do it and it&#39;ll deserve its own section. . One extra complexity is that images are typically encoded in sRGB to get properly displayed on digital monitors. So our first step will be to go from sRGB to linear RGB, and then from there to LMS. . Once in the LMS color space, colors that only differ by the coordinate of the axis corresponding to the missing cone cannot be differentiated by a dichromat. This creates so-called confusion lines, which are, by construction, parallel to the missing axis in the LMS color space. So according to this model a protanope cannot distinguish colors that only differ by their L component, a deuteranope those that only differ by their M component, and tritanopes those that only differ by their S component. . To illustrate this let&#39;s build a plot with a few confusion lines in the LMS space, and their counterpart on the linear RGB space. The code to generate the confusion lines is in the Appendix. We&#39;ll going to just draw 5 precomputed lines, starting with protanopia (missing L cones). To have a reference we&#39;ll also add the gamut (range) of colors that can be produced by a digital monitor. It&#39;s a cube in the RGB color space, and a parallelepiped in the LMS space. The 8 vertices are black (K = RGB[0,0,0]), white (W = RGB[1, 1, 1]), red (R = RGB[1, 0, 0]), green (G = RGB[0,1,0]), blue (B = RGB[0,0,1]), yellow (G = RGB[1,1,0]), magenta (M = RGB[1,0,1]) and cyan (C = RGB[0,1,1]). . The plots are in 3D and interactive, so feel free to play with the point of view! . # This cell defines all our imports and a few utilities import itertools import numpy as np import plotly.express as px import plotly.graph_objs as go from plotly.subplots import make_subplots import pandas as pd import Geometry3D as geo3d import daltonlens.convert as convert import daltonlens.generate as generate import daltonlens.simulate as simulate import daltonlens.geometry as geometry np.set_printoptions(suppress=True) def printMatrix(name, m): mat_str = &#39; n &#39;.join(np.array_repr(m).split(&#39; n&#39;)) print (f&#39;{name} = n {mat_str}&#39;) # Utility for plotly imshow hide_image_axes = dict(yaxis_visible=False, yaxis_showticklabels=False, xaxis_visible=False, xaxis_showticklabels=False, margin=dict(l=0, r=0, b=0, t=0)) . . def show_confusion_lines(title, lines): rgb_cube = pd.DataFrame.from_records([ (&#39;K&#39;, &#39;black&#39;, 0, 0, 0, 0. , 0. , 0. , &#39;#000000&#39;), (&#39;B&#39;, &#39;blue&#39;, 0, 0, 1, 0.03596577, 0.03620635, 0.01528089, &#39;#0000ff&#39;), (&#39;M&#39;, &#39;magenta&#39;, 1, 0, 1, 0.21482533, 0.07001029, 0.01559176, &#39;#ff00ff&#39;), (&#39;R&#39;, &#39;red&#39;, 1, 0, 0, 0.17885956, 0.03380394, 0.00031087, &#39;#ff0000&#39;), (&#39;G&#39;, &#39;green&#39;, 0, 1, 0, 0.43997117, 0.27515242, 0.00191661, &#39;#00ff00&#39;), (&#39;C&#39;, &#39;cyan&#39;, 0, 1, 1, 0.47593694, 0.31135877, 0.0171975 , &#39;#00ffff&#39;), (&#39;W&#39;, &#39;white&#39;, 1, 1, 1, 0.6547965 , 0.34516271, 0.01750837, &#39;#ffffff&#39;), (&#39;Y&#39;, &#39;yellow&#39;, 1, 1, 0, 0.61883073, 0.30895636, 0.00222748, &#39;#ffff00&#39;)], columns = [&#39;short_name&#39;, &#39;name&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;sRGB_hex&#39;]) rgb_cube.index = rgb_cube[&#39;short_name&#39;] rgb_cube.index.name = &#39;key&#39; # display(HTML(&quot;&lt;h2&gt;RGB Cube&lt;/h2&gt;&quot;), rgb_cube) fig = make_subplots(1,2, subplot_titles=(&#39;RGB Color Space&#39;, &#39;LMS Color Space&#39;), specs=[[{&quot;type&quot;: &quot;scene&quot;}, {&quot;type&quot;: &quot;scene&quot;}]]) fig.add_scatter3d(x=rgb_cube[&#39;R&#39;], y=rgb_cube[&#39;G&#39;], z=rgb_cube[&#39;B&#39;], text=rgb_cube.index, mode=&quot;markers+text&quot;, showlegend=False, marker=dict(color=rgb_cube[&#39;sRGB_hex&#39;]), row=1, col=1) fig.add_scatter3d(x=rgb_cube[&#39;L&#39;], y=rgb_cube[&#39;M&#39;], z=rgb_cube[&#39;S&#39;], text=rgb_cube.index, mode=&quot;markers+text&quot;, showlegend=False, marker=dict(color=rgb_cube[&#39;sRGB_hex&#39;]), row=1, col=2) fig.update_layout(title=title) fig.update_layout(dragmode=&#39;orbit&#39;, scene = dict( xaxis_title=&#39;R&#39;, yaxis_title=&#39;G&#39;, zaxis_title=&#39;B&#39;)) fig.update_layout(scene2 = dict( xaxis_title=&#39;L&#39;, yaxis_title=&#39;M&#39;, zaxis_title=&#39;S&#39;)) # Add the parallelepiped lines df = rgb_cube.loc[[&#39;K&#39;,&#39;B&#39;,&#39;M&#39;,&#39;R&#39;, &#39;K&#39;, &#39;G&#39;, &#39;Y&#39;, &#39;W&#39;, &#39;C&#39;, &#39;G&#39;, &#39;Y&#39;, &#39;R&#39;, &#39;M&#39;, &#39;W&#39;, &#39;C&#39;, &#39;B&#39;]] fig.add_scatter3d(x=df[&#39;R&#39;], y=df[&#39;G&#39;], z=df[&#39;B&#39;], mode=&#39;lines&#39;, showlegend=False, row=1, col=1) fig.add_scatter3d(x=df[&#39;L&#39;], y=df[&#39;M&#39;], z=df[&#39;S&#39;], mode=&#39;lines&#39;, showlegend=False, row=1, col=2) for line in lines: fig.add_scatter3d(x=line[&#39;R&#39;], y=line[&#39;G&#39;], z=line[&#39;B&#39;], showlegend=False, marker=dict(color=line[&#39;sRGB_hex&#39;]), row=1, col=1) fig.add_scatter3d(x=line[&#39;L&#39;], y=line[&#39;M&#39;], z=line[&#39;S&#39;], showlegend=False, marker=dict(color=line[&#39;sRGB_hex&#39;]), row=1, col=2) fig.show() # Confusion lines for Deficiency.PROTAN protan_confusion_lines = [ pd.DataFrame.from_records([ (0.2309, 0.0690, 0.0035, 1.0000, 0.1022, 0.1960, &#39;#fe5a7a&#39;), (0.2101, 0.0690, 0.0035, 0.8333, 0.1226, 0.1968, &#39;#eb627a&#39;), (0.1893, 0.0690, 0.0035, 0.6667, 0.1430, 0.1977, &#39;#d5697a&#39;), (0.1684, 0.0690, 0.0035, 0.5000, 0.1633, 0.1985, &#39;#bb707b&#39;), (0.1476, 0.0690, 0.0035, 0.3334, 0.1837, 0.1993, &#39;#9c767b&#39;), (0.1268, 0.0690, 0.0035, 0.1667, 0.2041, 0.2002, &#39;#717c7b&#39;), (0.1060, 0.0690, 0.0035, 0.0001, 0.2244, 0.2010, &#39;#00827b&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.3899, 0.1726, 0.0088, 1.0000, 0.4389, 0.4975, &#39;#feb0bb&#39;), (0.3690, 0.1726, 0.0088, 0.8333, 0.4593, 0.4983, &#39;#ebb4bb&#39;), (0.3482, 0.1726, 0.0088, 0.6667, 0.4796, 0.4992, &#39;#d5b8bb&#39;), (0.3274, 0.1726, 0.0088, 0.5000, 0.5000, 0.5000, &#39;#bbbbbb&#39;), (0.3066, 0.1726, 0.0088, 0.3334, 0.5204, 0.5008, &#39;#9cbebb&#39;), (0.2858, 0.1726, 0.0088, 0.1667, 0.5407, 0.5017, &#39;#71c2bb&#39;), (0.2649, 0.1726, 0.0088, 0.0001, 0.5611, 0.5025, &#39;#00c5bb&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.2754, 0.1044, 0.0120, 1.0000, 0.1584, 0.7462, &#39;#fe6ee0&#39;), (0.2546, 0.1044, 0.0120, 0.8333, 0.1787, 0.7471, &#39;#eb75e0&#39;), (0.2337, 0.1044, 0.0120, 0.6667, 0.1991, 0.7479, &#39;#d57be0&#39;), (0.2129, 0.1044, 0.0120, 0.5000, 0.2194, 0.7487, &#39;#bb80e0&#39;), (0.1921, 0.1044, 0.0120, 0.3334, 0.2398, 0.7496, &#39;#9c86e0&#39;), (0.1713, 0.1044, 0.0120, 0.1667, 0.2602, 0.7504, &#39;#718be0&#39;), (0.1505, 0.1044, 0.0120, 0.0001, 0.2805, 0.7513, &#39;#0090e0&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.5043, 0.2408, 0.0055, 1.0000, 0.7195, 0.2487, &#39;#fedc88&#39;), (0.4835, 0.2408, 0.0055, 0.8333, 0.7398, 0.2496, &#39;#ebdf88&#39;), (0.4627, 0.2408, 0.0055, 0.6667, 0.7602, 0.2504, &#39;#d5e189&#39;), (0.4419, 0.2408, 0.0055, 0.5000, 0.7805, 0.2513, &#39;#bbe489&#39;), (0.4211, 0.2408, 0.0055, 0.3334, 0.8009, 0.2521, &#39;#9ce789&#39;), (0.4003, 0.2408, 0.0055, 0.1667, 0.8213, 0.2529, &#39;#71e989&#39;), (0.3794, 0.2408, 0.0055, 0.0001, 0.8416, 0.2538, &#39;#00ec89&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.5488, 0.2761, 0.0140, 1.0000, 0.7756, 0.7990, &#39;#fee3e6&#39;), (0.5280, 0.2761, 0.0140, 0.8333, 0.7959, 0.7998, &#39;#ebe6e7&#39;), (0.5072, 0.2761, 0.0140, 0.6667, 0.8163, 0.8007, &#39;#d5e9e7&#39;), (0.4864, 0.2761, 0.0140, 0.5000, 0.8367, 0.8015, &#39;#bbebe7&#39;), (0.4655, 0.2761, 0.0140, 0.3334, 0.8570, 0.8023, &#39;#9ceee7&#39;), (0.4447, 0.2761, 0.0140, 0.1667, 0.8774, 0.8032, &#39;#71f0e7&#39;), (0.4239, 0.2761, 0.0140, 0.0001, 0.8977, 0.8040, &#39;#00f3e7&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), ] show_confusion_lines(&#39;Examples of protan confusion lines&#39;, protan_confusion_lines) . . The colors of some of the 5 lines might be easier to discriminate for some protan, but overall with this point size they should be pretty difficult to differentiate on a monitor screen. . See how the confusion lines are parallel to the L axis in the LMS color space, but not aligned with any axis in the RGB space. As expected for protanopes, the colors along the confusion lines vary mostly by their red and green components and are pretty much orthogonal to the blue axis. . Let&#39;s also visualize some lines for deuteranopes (parallel to the M axis) and tritanopes (parallel to the S axis). . # Confusion lines for Deficiency.DEUTAN deutan_confusion_lines = [ pd.DataFrame.from_records([ (0.1310, 0.0311, 0.0035, 0.6889, 0.0000, 0.2151, &#39;#d8007f&#39;), (0.1310, 0.0400, 0.0035, 0.5741, 0.0470, 0.2116, &#39;#c73d7e&#39;), (0.1310, 0.0489, 0.0035, 0.4593, 0.0939, 0.2080, &#39;#b4567d&#39;), (0.1310, 0.0578, 0.0035, 0.3445, 0.1409, 0.2045, &#39;#9e687c&#39;), (0.1310, 0.0667, 0.0035, 0.2297, 0.1879, 0.2009, &#39;#83787b&#39;), (0.1310, 0.0756, 0.0035, 0.1149, 0.2348, 0.1974, &#39;#5f857a&#39;), (0.1310, 0.0846, 0.0035, 0.0000, 0.2818, 0.1938, &#39;#009079&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.3274, 0.1338, 0.0088, 1.0000, 0.2955, 0.5155, &#39;#fe93be&#39;), (0.3274, 0.1467, 0.0088, 0.8333, 0.3636, 0.5103, &#39;#eba2bd&#39;), (0.3274, 0.1596, 0.0088, 0.6667, 0.4318, 0.5052, &#39;#d5afbc&#39;), (0.3274, 0.1726, 0.0088, 0.5000, 0.5000, 0.5000, &#39;#bbbbbb&#39;), (0.3274, 0.1855, 0.0088, 0.3334, 0.5682, 0.4948, &#39;#9cc6ba&#39;), (0.3274, 0.1985, 0.0088, 0.1667, 0.6363, 0.4897, &#39;#71d0b9&#39;), (0.3274, 0.2114, 0.0088, 0.0001, 0.7045, 0.4845, &#39;#00dab8&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.1817, 0.0570, 0.0120, 0.8612, 0.0000, 0.7689, &#39;#ee00e3&#39;), (0.1817, 0.0681, 0.0120, 0.7176, 0.0587, 0.7645, &#39;#dc44e2&#39;), (0.1817, 0.0792, 0.0120, 0.5741, 0.1174, 0.7600, &#39;#c760e1&#39;), (0.1817, 0.0904, 0.0120, 0.4306, 0.1761, 0.7556, &#39;#af74e1&#39;), (0.1817, 0.1015, 0.0120, 0.2871, 0.2348, 0.7511, &#39;#9185e0&#39;), (0.1817, 0.1127, 0.0120, 0.1436, 0.2935, 0.7467, &#39;#6993e0&#39;), (0.1817, 0.1238, 0.0120, 0.0001, 0.3522, 0.7423, &#39;#00a0df&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.4731, 0.2214, 0.0055, 1.0000, 0.6477, 0.2577, &#39;#fed28a&#39;), (0.4731, 0.2325, 0.0055, 0.8565, 0.7064, 0.2533, &#39;#eeda89&#39;), (0.4731, 0.2436, 0.0055, 0.7130, 0.7652, 0.2489, &#39;#dbe288&#39;), (0.4731, 0.2548, 0.0055, 0.5694, 0.8239, 0.2444, &#39;#c6ea87&#39;), (0.4731, 0.2659, 0.0055, 0.4259, 0.8826, 0.2400, &#39;#aef186&#39;), (0.4731, 0.2771, 0.0055, 0.2824, 0.9413, 0.2355, &#39;#90f885&#39;), (0.4731, 0.2882, 0.0055, 0.1389, 1.0000, 0.2311, &#39;#68fe84&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.5238, 0.3141, 0.0140, 0.3111, 1.0000, 0.7849, &#39;#97fee5&#39;), (0.5238, 0.3052, 0.0140, 0.4259, 0.9530, 0.7884, &#39;#aef9e5&#39;), (0.5238, 0.2963, 0.0140, 0.5407, 0.9061, 0.7920, &#39;#c2f4e6&#39;), (0.5238, 0.2873, 0.0140, 0.6555, 0.8591, 0.7955, &#39;#d3eee6&#39;), (0.5238, 0.2784, 0.0140, 0.7703, 0.8121, 0.7991, &#39;#e3e8e6&#39;), (0.5238, 0.2695, 0.0140, 0.8851, 0.7652, 0.8026, &#39;#f1e2e7&#39;), (0.5238, 0.2606, 0.0140, 1.0000, 0.7182, 0.8062, &#39;#fedce7&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), ] show_confusion_lines(&#39;Examples of deutan confusion lines&#39;, deutan_confusion_lines) . . # Confusion lines for Deficiency.TRITAN tritan_confusion_lines = [ pd.DataFrame.from_records([ (0.1310, 0.0690, 0.0005, 0.1649, 0.2306, 0.0000, &#39;#708300&#39;), (0.1310, 0.0690, 0.0030, 0.1941, 0.2051, 0.1667, &#39;#797d71&#39;), (0.1310, 0.0690, 0.0055, 0.2234, 0.1796, 0.3333, &#39;#82759c&#39;), (0.1310, 0.0690, 0.0080, 0.2527, 0.1541, 0.5000, &#39;#896dbb&#39;), (0.1310, 0.0690, 0.0105, 0.2820, 0.1285, 0.6666, &#39;#9064d5&#39;), (0.1310, 0.0690, 0.0130, 0.3113, 0.1030, 0.8333, &#39;#975aeb&#39;), (0.1310, 0.0690, 0.0155, 0.3405, 0.0775, 0.9999, &#39;#9d4efe&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.3274, 0.1726, 0.0163, 0.5878, 0.4234, 1.0000, &#39;#c9aefe&#39;), (0.3274, 0.1726, 0.0138, 0.5586, 0.4489, 0.8333, &#39;#c5b2eb&#39;), (0.3274, 0.1726, 0.0113, 0.5293, 0.4745, 0.6667, &#39;#c0b7d5&#39;), (0.3274, 0.1726, 0.0088, 0.5000, 0.5000, 0.5000, &#39;#bbbbbb&#39;), (0.3274, 0.1726, 0.0062, 0.4707, 0.5255, 0.3334, &#39;#b6bf9c&#39;), (0.3274, 0.1726, 0.0037, 0.4414, 0.5510, 0.1667, &#39;#b1c371&#39;), (0.3274, 0.1726, 0.0012, 0.4122, 0.5766, 0.0001, &#39;#abc700&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.1817, 0.1044, 0.0158, 0.2939, 0.2117, 1.0000, &#39;#937efe&#39;), (0.1817, 0.1044, 0.0133, 0.2646, 0.2372, 0.8333, &#39;#8c85eb&#39;), (0.1817, 0.1044, 0.0108, 0.2354, 0.2628, 0.6667, &#39;#858cd5&#39;), (0.1817, 0.1044, 0.0083, 0.2061, 0.2883, 0.5000, &#39;#7d92bb&#39;), (0.1817, 0.1044, 0.0058, 0.1768, 0.3138, 0.3334, &#39;#74979c&#39;), (0.1817, 0.1044, 0.0032, 0.1475, 0.3393, 0.1667, &#39;#6b9d71&#39;), (0.1817, 0.1044, 0.0007, 0.1182, 0.3649, 0.0001, &#39;#60a200&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.4731, 0.2408, 0.0168, 0.8818, 0.6351, 1.0000, &#39;#f1d0fe&#39;), (0.4731, 0.2408, 0.0143, 0.8525, 0.6606, 0.8333, &#39;#edd4eb&#39;), (0.4731, 0.2408, 0.0118, 0.8232, 0.6862, 0.6667, &#39;#ead7d5&#39;), (0.4731, 0.2408, 0.0093, 0.7939, 0.7117, 0.5000, &#39;#e6dbbb&#39;), (0.4731, 0.2408, 0.0067, 0.7646, 0.7372, 0.3334, &#39;#e2de9c&#39;), (0.4731, 0.2408, 0.0042, 0.7354, 0.7628, 0.1667, &#39;#dee271&#39;), (0.4731, 0.2408, 0.0017, 0.7061, 0.7883, 0.0001, &#39;#dae500&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.5238, 0.2761, 0.0170, 0.8351, 0.7694, 1.0000, &#39;#ebe3fe&#39;), (0.5238, 0.2761, 0.0145, 0.8059, 0.7949, 0.8333, &#39;#e7e6eb&#39;), (0.5238, 0.2761, 0.0120, 0.7766, 0.8204, 0.6667, &#39;#e4e9d5&#39;), (0.5238, 0.2761, 0.0095, 0.7473, 0.8459, 0.5000, &#39;#e0ecbb&#39;), (0.5238, 0.2761, 0.0070, 0.7180, 0.8715, 0.3334, &#39;#dcf09c&#39;), (0.5238, 0.2761, 0.0045, 0.6887, 0.8970, 0.1667, &#39;#d8f371&#39;), (0.5238, 0.2761, 0.0020, 0.6595, 0.9225, 0.0001, &#39;#d4f600&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), ] show_confusion_lines(&#39;Examples of tritan confusion lines&#39;, tritan_confusion_lines) . . The deutan confusion lines are somewhat similar to the protan confusion lines (this is why both are called red-green deficiency), but the tritan ones are mostly along the blue axis. . At this stage if you are affected by a color vision deficiency you might already have a more precise idea of what kind of dichromacy better models your color vision. For me the colors on the protan confusion lines look pretty similar at such a small point size, but I can better distinguish the deutan lines and very well the tritan ones, confirming that I am a protan. . So now that we can compute these confusion lines for each kind of dichromacy, can we simulate how a person with a CVD sees? Since it&#39;s related to perception it&#39;s impossible to know how another person &quot;feels&quot; the colors, but to understand the loss of color sensitivity we can transform images so that all the colors on each confusion line projects to a single one, essentially making the color space 2D. If the models are correct then the transformed image should still appear identical to a dichromat, and a trichromat will get a sense of the color differences that get lost for the dichromat. . The remaining question is what color should we pick to represent each confusion line? That will be the subject of the Simulating dichromacy in LMS section. . Finally once the LMS colors are projected along the confusion lines, we can transform them back to the linearRGB and then sRGB color spaces to get the final simulated image. The overall process is summarized in the diagram below, and we&#39;re going to dive into each part in the next sections. . . From sRGB to LMS . In this section we&#39;re going to review the steps to go to that nice LMS color space. Several models have been proposed in the literature, so there is not just one way to do it. . From sRGB to linearRGB . Most digital images are encoded with 3 values per pixel: red, green and blue. But what is often neglected is that this &quot;RGB&quot; usually corresponds to the sRGB standard that precisely defines how these values should be interpreted. sRGB is not a linear space because it tries to compensate the non-linear gamma factor applied by monitors, so that the image captured by a digital camera and then rendered on a monitor will look like the original scene. . We&#39;ll call the RGB color space after removing that non-linearity the linearRGB color space. The transformation roughly corresponds to applying a gamma exponent of 2.4 on each channel like a typical monitor would do, with a special linear slope for very small values. So unlike all the other color transformations of that notebook it is non-linear and cannot be expressed as a matrix. . The good news is that sRGB is a well-defined standard now, so we just need to implement the function given by the standard. For more details see the wikipedia page. . Since both Brettel 1997 and Viénot 1999 were published before the sRGB standard became mainstream, they had to calibrate their old CRT monitor and publish their own model in the paper. Their matrices must be adapted to use the new sRGB model. Even worse, even if the Viénot 1999 paper explicitly mentions the required non-linear transform for their CRT monitor, the most widely replicated matlab code from (Fidaner, Lin, &amp; Ozguven, 2005) does not take it into account and directly treat the input image as linear RGB. As a consequence this is also the case of most of the source code listed on (Daltonize.org, 2010). . Does it matter? Yes! . As you can see in the image below forgetting the sRGB -&gt; linearRGB transform makes a big difference and it can invalidate perceptual experiments. The first row has 4 sRGB colors, and the second row shows the same colors wrongly interpreted as linear RGB. . im_sRGB = np.array([[[127,0,0], [64,128,0], [0, 0, 192], [64, 64, 192]]], dtype=float) / 255.0 px.imshow(np.vstack([im_sRGB, # First row is the sRGB content convert.linearRGB_from_sRGB(im_sRGB)]), height=200).update_layout(hide_image_axes) . . And the impact is also significant on the final simulation, here is a comparison of Viénot 1999 implemented with and without the proper sRGB decoding / encoding. Note how a bunch of colors appear too dark in the simulation without sRGB. . . Original Viénot 1999Viénot 1999 without sRGB . | | | . From linearRGB to CIE XYZ . So far we only mentioned the LMS color space, saying that we&#39;d just go from linearRGB to LMS. But to understand the literature around that transform it is necessary to add an intermediate step which is the CIE XYZ color space. The reason is historical, this color space was standardized in 1931 and it has been used as the main space for color science research since. The main reason is that it can (almost) represent the full range of colors that can be perceived by an average human observer with just 3 values, is device-independent, and has a well-defined relationship w.r.t the input light spectrum. . Dichromats confusion lines are sometimes shown in the CIE XYZ color space (e.g. on color-blindness.com), usually drawing the lines on a so-called chromaticity diagram. These diagram are a 2d projection of the CIE XYZ color space for a constant maximal luminance. I always got confused about those because I could clearly see differences along these lines, especially when they transition from green to red. The reason is that the confusion lines are actually 3d in CIE XYZ and the luminance needs to get adjusted as the hue/chroma changes along the line to actually get confused by a dichromat. The sRGB wikipedia page gives the XYZ_from_linearRGB matrix defined by the standard itself. As we noted Viénot 1999 used a different matrix resulting from a generic CRT monitor. That matrix was kept in (Fidaner, Lin, &amp; Ozguven, 2005) and is thus still widespread today. . However as (Simon-Liedtke &amp; Farup, 2016) noted, we should now use the modern sRGB-induced transform for LCD monitors. This is also the model correctly used by (Dietrich &amp; daltonize.py, 2020) and (Jim &amp; Ixora, 2021). . printMatrix(&#39;Vienot1999 XYZ_from_linearRGB (for old CRT)&#39;, convert.LMSModel_Vienot1999_SmithPokorny75().XYZ_from_linearRGB*255.0); print() printMatrix(&#39;sRGB XYZ_from_linearRGB (use this one!)&#39;, convert.LMSModel_sRGB_SmithPokorny75().XYZ_from_linearRGB*255) . . Vienot1999 XYZ_from_linearRGB (for old CRT) = array([[40.9567995 , 35.5040988 , 17.91670035], [21.3388998 , 70.6743006 , 7.9867989 ], [ 1.8629688 , 11.4620001 , 91.2366999 ]]) sRGB XYZ_from_linearRGB (use this one!) = array([[105.17628 , 91.1819055, 46.0115625], [ 54.23136 , 182.363811 , 18.404625 ], [ 4.929915 , 30.39396 , 242.3275455]]) . From CIE XYZ to LMS . That conversion is less clear as many more transforms have been proposed, with different motivations. The most relevant models for CVD simulations are based on color matching experiments with people who happen to have one normal trichromat eye and one dichromat eye (unilateral dichromats). . The most widely used conversion for CVD simulation is still (Smith &amp; Pokorny, 1975), which is the one used by Brettel 1997 and Viénot 1999. The earlier seminal work of (Meyer &amp; Greenberg, 1988) used another transform from (Estévez, 1981) but it already mentioned (Smith &amp; Pokorny, 1975) as being a good candidate. Another popular reference model in the literature is the Hunt-Pointer-Esterez one (missing reference). It is used a lot for chromatic adaptation (predicting how a perceived color will change with the illumination conditions), but less for CVD simulation experiments. . (Stockman &amp; Sharpe, 2000) made a thorough comparison of the models, and they also propose a new matrix (for a 10 degree standard observer). But overall they are in good agreement with (Smith &amp; Pokorny, 1975) once adjusted for a 2 degree observer, with larger differences compared to Hunt-Pointer-Esterez. All 3 are probably reasonable options, but since the CVD simulation evaluations were most often made and evaluated with Smith &amp; Pokorny it&#39;s probably still the most solid choice, despite its age. It is also interesting to note that both Pokorny and Viénot continue to promote that transform in more recent papers (Viénot &amp; Le Rohellec, 2013) (Smith &amp; Pokorny, 2003), and other recent papers in the color science research literature do the same (Machado, Oliveira, &amp; Fernandes, 2009) (Simon-Liedtke &amp; Farup, 2016). . Most open source code uses the Smith and Pokorny since they did not modify the original code, but some did. (Jim &amp; Ixora, 2021) uses the Hunt-Pointer-Estevez matrix and (Dietrich &amp; daltonize.py, 2020) uses the sharpened transformation matrix of CIECAM02. These two matrices are on the Wikipedia page and look attractive as they are more recent. But at least the &quot;sharpened&quot; matrices variants are not meant to match the physiological cone responses but to perform hue-preserving chromatic adaptation (see the discussion p181 of (Fairchild, 2013)). So I would argue that we should keep using Smith &amp; Pokorny transform until a proper validation of newer matrices gets done in the context of CVD simulation. . The XYZ&lt;-&gt;LMS matrices of the different models can look very different, but the main reason is the normalization factor. There is no unique &quot;scale&quot; for each axis, so each model picked a convention. For example Smith &amp; Pokorny made it so L+S=Y and S/Y=1 at the 400nm wavelengths. For Hunt-Pointer-Esterez they normalize it so that L=M=S for the equal-energy illuminant E (X=Y=Z=1/3), which means that the sum of each rows equals to 1. One reason for this scale variance is that the human vision system can actually change it independently for each axis depending on the illumination conditions. This process is called chromatic adaptation and explains why we still perceive a white sheet of paper as white under an incandescent indoor lighting that makes it actually yellow-ish. It&#39;s a bit similar to the white balance correction of digital cameras. These normalizations do not really matter for CVD simulation if we only do linear operations in it, the scale factor will cancel out when we go back to RGB. . Below are some example of those LMS_from_XYZ matrices. . printMatrix(&#39;Smith &amp; Pokorny (used by Viénot, recommended) LMS_from_XYZ&#39;, convert.LMSModel_Vienot1999_SmithPokorny75().LMS_from_XYZ); print() printMatrix(&#39;Hunt-Pointer-Estevez LMS_from_XYZ&#39;, convert.LMSModel_sRGB_HuntPointerEstevez().LMS_from_XYZ); print() printMatrix(&#39;Stockman-Sharpe LMS_from_XYZ&#39;, convert.LMSModel_sRGB_StockmanSharpe2000().LMS_from_XYZ); print() . . Smith &amp; Pokorny (used by Viénot, recommended) LMS_from_XYZ = array([[ 0.15514, 0.54312, -0.03286], [-0.15514, 0.45684, 0.03286], [ 0. , 0. , 0.01608]]) Hunt-Pointer-Estevez LMS_from_XYZ = array([[ 0.4002, 0.7076, -0.0808], [-0.2263, 1.1653, 0.0457], [ 0. , 0. , 0.9182]]) Stockman-Sharpe LMS_from_XYZ = array([[ 1.94735469, -1.41445123, 0.36476327], [ 0.68990272, 0.34832189, 0. ], [ 0. , 0. , 1.93485343]]) . From linearRGB to LMS . Since both XYZ_from_linearRGB and LMS_from_XYZ are linear transforms, we can just combine the two matrices to get a final LMS_from_linearRGB = LMS_from_XYZ . XYZ_from_linearRGB transform. Here are some of the models implemented in DaltonLens-Python, scaled by 255 for an easier comparison with existing open source code: . printMatrix(&#39;Viénot 1999 (old CRT monitor, do not use) nLMS_from_linearRGB&#39;, convert.LMSModel_Vienot1999_SmithPokorny75().LMS_from_linearRGB*255.0); print() printMatrix(&#39;sRGB Viénot (recommended) nLMS_from_linearRGB&#39;, convert.LMSModel_sRGB_SmithPokorny75().LMS_from_linearRGB*255.0); print() printMatrix(&#39;Hunt-Pointer-Esterez nLMS_from_linearRGB&#39;, convert.LMSModel_sRGB_HuntPointerEstevez().LMS_from_linearRGB*255.0); print() printMatrix(&#39;Stockman &amp; Sharpe nLMS_from_linearRGB&#39;, convert.LMSModel_sRGB_StockmanSharpe2000().LMS_from_linearRGB*255.0); print() . . Viénot 1999 (old CRT monitor, do not use) LMS_from_linearRGB = array([[17.88240398, 43.51609071, 4.11934915], [ 3.45564226, 27.15538292, 3.86713028], [ 0.02995654, 0.18430896, 1.46708613]]) sRGB Viénot (recommended) LMS_from_linearRGB = array([[ 45.60918732, 112.19264832, 9.17127059], [ 8.62000343, 70.16386812, 9.23261822], [ 0.07927303, 0.48873488, 3.89662693]]) Hunt-Pointer-Esterez LMS_from_linearRGB = array([[ 80.06732046, 163.07579928, 11.85687429], [ 39.61970876, 193.26308772, 22.10886175], [ 4.52664795, 27.90773407, 222.50515228]]) Stockman &amp; Sharpe LMS_from_linearRGB = array([[129.90616019, -69.29460522, 151.96057547], [ 91.45137146, 126.42795193, 38.15423588], [ 9.53866295, 58.80785776, 468.86828259]]) . Simulating dichromacy in LMS (Brettel 1997 and Vi&#233;not 1999) . Let&#39;s rebuild the seminal paper of (Brettel &amp; Mollon, 1997) that built a precise model based on perceptual experiments. (Viénot, Brettel, &amp; Mollon, 1999) then simplified it for its use with digital monitors, reducing the whole pipeline to a single matrix multiplication, and we&#39;ll see it right after. . Projection planes in LMS . Now that we are in a color space that better matches the human physiology, the question becomes how to transform the LMS coordinates to simulate what a color blind person perceives. As discussed in the Introduction, we want all the colors along the confusion lines to project to the same one, so that a dichromat won&#39;t see a difference in the transformed image, but a trichromat will see how much of the color information is lost by the dichromat. . As (Jim &amp; Ixora, 2021) points out, a first idea is to just set the deficient axis to 0. But that won&#39;t work for several reasons: . 1) The new point with L=0, S=0 or M=0 is likely to be outside of the sRGB gamut (the parallelepiped we visualized before in LMS), so most of these transformed color would not be valid once transformed back to sRGB. . 2) Experiments on unilateral dichromats (people who have one normal trichromat eye and one dichromat eye) show that they perceive some colors similarly with both eyes. Unsurprisingly among these invariant stimulus we find shades of gray (black to white). Then the similar colors for the two eyes are observed along the 475nm (blue-greenish) and 575nm (yellow) axes for protans and deutans, and along the 485nm (cyan) and 660nm (red) axes for tritans. (Meyer &amp; Greenberg, 1988) has solid references for some of these experiments, made in the 1950s. Intuitively it makes sense that the dichromat eye of a protan or deutan does a good job on colors that only differ by the amount of blue (S cone). Indeed in LMS going from black to blue or white to yellow is just a change in the S coordinate. . Based on that that data it is possible to design a projection that respect these constraints. (Brettel &amp; Mollon, 1997) proposed the first modern algorithm to compute that. It consists in creating two half-planes around the Black-White diagonal. For protanopes and deuteranopes the wings go through the LMS coordinates of the 475nm and 575nm wavelengths, and for tritanopes towards the coordinates of the 485nm and 660nm wavelengths. By construction colors that lie on these invariant axes are thus preserved. . While black just has a (0,0,0) coordinate in LMS, &quot;white&quot; needs a more careful definition. In (Brettel &amp; Mollon, 1997) they take the white point of the equal-energy illuminant as the neutral axis. That illuminant (called E in CIE XYZ terminology) has the same amount of energy on all the visible light wavelengths, so it presents a perfectly even color. It differs a bit from the &quot;white&quot; of a sRGB monitor which is the white point of the D65 illuminant, which roughly corresponds to the stimulus we&#39;d perceive as white under average outdoor daylight. So to stay close to the best theoretical value we&#39;ll start by considering Black to E as the neutral axis that dichromats perceive similarly as trichromats. . Let&#39;s first visualize how these planes look like in 3D for protans/deutans (they share the same plane) and for tritans. Note that the colors corresponding to pure 475nm, 485nm, 575nm and 660nm cannot be represented on a sRGB monitor, so I use their closest approximation in the plot by de-saturating them (adding &quot;white&quot; to them until they fit in the gamut). . lms_model = convert.LMSModel_sRGB_SmithPokorny75() # lms_model = convert.LMSModel_Vienot1999_SmithPokorny75() # lms_model = convert.LMSModel_sRGB_StockmanSharpe2000() import colour # from pip install colour-science from colour import MSDS_CMFS cmfs = MSDS_CMFS[&#39;CIE 1931 2 Degree Standard Observer&#39;] xyz_475 = colour.wavelength_to_XYZ(475, cmfs) xyz_575 = colour.wavelength_to_XYZ(575, cmfs) xyz_485 = colour.wavelength_to_XYZ(485, cmfs) xyz_660 = colour.wavelength_to_XYZ(660, cmfs) # From https://www.johndcook.com/wavelength_to_RGB.html # Approximate since the XYZ coordinates are not actually in the RGB gamut # The correspondence has to be done projecting in the direction of the # whitepoint until reaching the gamut. # http://www.fourmilab.ch/documents/specrend/ lms_475 = lms_model.LMS_from_XYZ @ xyz_475 lms_575 = lms_model.LMS_from_XYZ @ xyz_575 lms_485 = lms_model.LMS_from_XYZ @ xyz_485 lms_660 = lms_model.LMS_from_XYZ @ xyz_660 # The equal-energy white point. By construction of CIE XYZ # it has X=Y=Z. The normalization does not matter to define # the diagonal direction, picking 0.8 to make it close to # sRGB white. xyz_E = [0.8, 0.8, 0.8] rgb_E = lms_model.linearRGB_from_XYZ @ xyz_E srgb_E = convert.sRGB_from_linearRGB([rgb_E]) lms_E = lms_model.LMS_from_XYZ @ xyz_E rgb_wavelengths = convert.apply_color_matrix(np.array([xyz_475, xyz_575, xyz_485, xyz_660]), lms_model.linearRGB_from_XYZ) rgb_wavelengths = convert.desaturate_linearRGB_to_fit_in_gamut(rgb_wavelengths) srgb_wavelengths = convert.sRGB_from_linearRGB(rgb_wavelengths) rgb_475, rgb_575, rgb_485, rgb_660 = srgb_wavelengths rgb_gamut = [ (np.array([0.0, 0.0, 0.0]), &#39;K&#39;, &#39;black&#39;), (np.array([0.0, 0.0, 1.0]), &#39;B&#39;, &#39;blue&#39;), (np.array([1.0, 0.0, 1.0]), &#39;M&#39;, &#39;magenta&#39;), (np.array([1.0, 0.0, 0.0]), &#39;R&#39;, &#39;red&#39;), (np.array([0.0, 1.0, 0.0]), &#39;G&#39;, &#39;green&#39;), (np.array([0.0, 1.0, 1.0]), &#39;C&#39;, &#39;cyan&#39;), (np.array([1.0, 1.0, 1.0]), &#39;W&#39;, &#39;white&#39;), (np.array([1.0, 1.0, 0.0]), &#39;Y&#39;, &#39;yellow&#39;), ] def dataframe_row(rgb, lms, short_name:str, name: str): int_rgb255 = (rgb*255.0).astype(np.uint8) return [name, short_name, *rgb, *lms, f&#39;#{int_rgb255[0]:02x}{int_rgb255[1]:02x}{int_rgb255[2]:02x}&#39;] def lms_of_key(df, key): return np.array(df.loc[key, [&#39;L&#39;,&#39;M&#39;,&#39;S&#39;]], dtype=float) # RGB parallelepiped gamut in LMS df_rows = [dataframe_row(row[0], lms_model.LMS_from_linearRGB @ row[0], row[1], row[2]) for row in rgb_gamut] df_rows.append(dataframe_row(rgb_E, lms_E, &#39;E&#39;, &#39;Equal-Energy&#39;)) df_rows.append(dataframe_row(rgb_475, lms_475, &#39;475nm&#39;, &#39;475nm&#39;)) df_rows.append(dataframe_row(rgb_575, lms_575, &#39;575nm&#39;, &#39;575nm&#39;)) df_rows.append(dataframe_row(rgb_485, lms_485, &#39;485nm&#39;, &#39;485nm&#39;)) df_rows.append(dataframe_row(rgb_660, lms_660, &#39;660nm&#39;, &#39;660nm&#39;)) KBMRGCWY = pd.DataFrame(df_rows, columns=[&#39;name&#39;, &#39;short_name&#39;, &#39;R&#39;,&#39;G&#39;,&#39;B&#39;,&#39;L&#39;,&#39;M&#39;,&#39;S&#39;,&#39;colorhex&#39;]) KBMRGCWY.set_index(&#39;short_name&#39;, inplace=True) KBMRGCWY[&#39;short_name&#39;] = KBMRGCWY.index KBMRGCWY_red_green = KBMRGCWY[0:-2] # drop 485 and 660nm KBMRGCWY_tritan = KBMRGCWY.drop(KBMRGCWY.index[-4:-2]) # drop 475 and 575nm figs = [ px.scatter_3d(KBMRGCWY_red_green, x=&#39;L&#39;, y=&#39;M&#39;, z=&#39;S&#39;, color=&#39;colorhex&#39;, color_discrete_map=&#39;identity&#39;, text=&#39;short_name&#39;, width=800, height=800, title=&#39;Protan and Deutan Projection Half-Planes according to (Brettel &amp; Mollon, 1997)&#39;), px.scatter_3d(KBMRGCWY_tritan, x=&#39;L&#39;, y=&#39;M&#39;, z=&#39;S&#39;, color=&#39;colorhex&#39;, color_discrete_map=&#39;identity&#39;, text=&#39;short_name&#39;, width=800, height=800, title=&#39;Tritan Projection Half-Planes according to (Brettel &amp; Mollon, 1997)&#39;) ] # Add the parallelepiped lines df = KBMRGCWY.loc[[&#39;K&#39;,&#39;B&#39;,&#39;M&#39;,&#39;R&#39;, &#39;K&#39;, &#39;G&#39;, &#39;Y&#39;, &#39;W&#39;, &#39;C&#39;, &#39;G&#39;, &#39;Y&#39;, &#39;R&#39;, &#39;M&#39;, &#39;W&#39;, &#39;C&#39;, &#39;B&#39;]] for fig in figs: fig.add_scatter3d(x=df[&#39;L&#39;], y=df[&#39;M&#39;], z=df[&#39;S&#39;], mode=&#39;lines&#39;, showlegend=False) # Add the black-E diagonal, dashed df = KBMRGCWY.loc[[&#39;K&#39;,&#39;E&#39;]] for fig in figs: fig.add_scatter3d(x=df[&#39;L&#39;], y=df[&#39;M&#39;], z=df[&#39;S&#39;], mode=&#39;lines&#39;, showlegend=False, line=dict(width=8, dash=&#39;dash&#39;, color=&#39;gray&#39;), row=1, col=1) def add_half_plane(fig, df, wavelength_key, col, U_norm, V_norm, delaunayaxis=&#39;x&#39;): # The plane is defined by two vectors starting from the origin # U is the black-white diagonal, and V is U = lms_of_key(df, &#39;E&#39;) - lms_of_key(df, &#39;K&#39;) U = U_norm * (U / np.linalg.norm(U)) V = lms_of_key(df, wavelength_key) - lms_of_key(df, &#39;K&#39;) N = np.cross(U,V) V = np.cross(N,U) V = V_norm * (V / np.linalg.norm(V)) u,v = np.mgrid[0:1:50j, 0:1:50j] xyz = u[...,np.newaxis]*U + v[...,np.newaxis]*V x = xyz[...,0].flatten() y = xyz[...,1].flatten() z = xyz[...,2].flatten() surfacecolor = convert.apply_color_matrix(xyz, lms_model.linearRGB_from_LMS) surfacecolor = convert.desaturate_linearRGB_to_fit_in_gamut(surfacecolor) surfacecolor = surfacecolor.reshape(-1,3) #display(surfacecolor) surfacecolor = convert.sRGB_from_linearRGB(surfacecolor) fig.add_mesh3d(z=z, x=x, y=y, opacity=1.0, delaunayaxis=delaunayaxis, alphahull=-1, vertexcolor=surfacecolor, lighting=dict(ambient=1.0,specular=0.0,diffuse=0.0), showlegend=False) df = KBMRGCWY_red_green add_half_plane(figs[0], df, &#39;475nm&#39;, 1, np.linalg.norm(lms_of_key(df, &#39;E&#39;))*1.5, lms_of_key(df, &#39;B&#39;)[2]*3) add_half_plane(figs[0], df, &#39;575nm&#39;, 1, np.linalg.norm(lms_of_key(df, &#39;E&#39;))*1.5, lms_of_key(df, &#39;B&#39;)[2]*3) df = KBMRGCWY_tritan add_half_plane(figs[1], df, &#39;485nm&#39;, 2, np.linalg.norm(lms_of_key(df, &#39;E&#39;))*1.5, np.linalg.norm(lms_of_key(df, &#39;B&#39;))*2, &#39;y&#39;) add_half_plane(figs[1], df, &#39;660nm&#39;, 2, np.linalg.norm(lms_of_key(df, &#39;E&#39;))*1.5, np.linalg.norm(lms_of_key(df, &#39;R&#39;))*0.5, &#39;y&#39;) camera = dict( up=dict(x=0, y=0, z=1), center=dict(x=0, y=0, z=0), eye=dict(x=-1.75, y=-1.75, z=0.75), ) for fig in figs: fig.update_layout(scene_camera=camera, dragmode=&#39;orbit&#39;) fig.show() . . If the model were perfect then these planes would show the entire set of colors that can be perceived by a dichromat. The idea of (Brettel &amp; Mollon, 1997) is then to project every LMS color into these planes along the dichromat missing axis, picking the closest of the 2 planes. But from these 3d plots we observe two things: . For protans and deutans the two wings are almost co-planar, and the plane is very close to passing through the white, blue and yellow limits of the sRGB parallelepiped. So (Viénot, Brettel, &amp; Mollon, 1999) proposed to simplify the algorithm by using a single diagonal plane black-white-blue-yellow. As we&#39;ll see next this makes it possible to make the projection a 3x3 matrix and reduce the full pipeline to a single 3x3 matrix. . | (Viénot, Brettel, &amp; Mollon, 1999) did not address the tritanope case though, and we can see that such an approximation would not be as good. Several open source implementations of the paper just use the same black-white-blue-yellow diagonal plane as the protan/deutan one, which is completely wrong, as (Jim &amp; Ixora, 2021) mentions. A better single plane approximation would be black-white-red-cyan, but it&#39;s still a rough approximation and unclear how accurate this is as evaluation studies are rare for tritanopes. . | . Let&#39;s visualize how the Viénot simplification looks like and derive their full algorithm. . The simplification of Vi&#233;not 1999 for protanopes and deuteranopes . In (Viénot, Brettel, &amp; Mollon, 1999) a single plane black-white-blue-yellow is created and all the colors will get projected onto it. Let&#39;s visualize that plane in 3D. . # RGB parallelepiped gamut in LMS fig = px.scatter_3d(KBMRGCWY.loc[&#39;K&#39;:&#39;Y&#39;], x=&#39;L&#39;, y=&#39;M&#39;, z=&#39;S&#39;, color=&#39;colorhex&#39;, color_discrete_map=&#39;identity&#39;, text=&#39;short_name&#39;, width=800, height=800, title=&#39;Protan and Deutan Projection Plane according to (Viénot &amp; Brettel &amp; Mollon, 1999)&#39;) # Add the parallelepiped lines df = KBMRGCWY.loc[[&#39;K&#39;,&#39;B&#39;,&#39;M&#39;,&#39;R&#39;, &#39;K&#39;, &#39;G&#39;, &#39;Y&#39;, &#39;W&#39;, &#39;C&#39;, &#39;G&#39;, &#39;Y&#39;, &#39;R&#39;, &#39;M&#39;, &#39;W&#39;, &#39;C&#39;, &#39;B&#39;]] fig.add_scatter3d(x=df[&#39;L&#39;], y=df[&#39;M&#39;], z=df[&#39;S&#39;], mode=&#39;lines&#39;, showlegend=False) # Add the black-white diagonal, dashed df = KBMRGCWY.loc[[&#39;K&#39;,&#39;W&#39;]] fig.add_scatter3d(x=df[&#39;L&#39;], y=df[&#39;M&#39;], z=df[&#39;S&#39;], mode=&#39;lines&#39;, showlegend=False, line=dict(width=8, dash=&#39;dash&#39;, color=&#39;gray&#39;), row=1, col=1) def add_black_white_yellow_blue_plane(fig, df): # The plane is defined by two vectors starting from the origin # U is the black-white diagonal, and V is U = lms_of_key(df, &#39;Y&#39;) - lms_of_key(df, &#39;K&#39;) V = lms_of_key(df, &#39;B&#39;) - lms_of_key(df, &#39;K&#39;) u,v = np.mgrid[0:1:50j, 0:1:50j] xyz = u[...,np.newaxis]*U + v[...,np.newaxis]*V x = xyz[...,0].flatten() y = xyz[...,1].flatten() z = xyz[...,2].flatten() surfacecolor = convert.apply_color_matrix(xyz, lms_model.linearRGB_from_LMS) surfacecolor = convert.desaturate_linearRGB_to_fit_in_gamut(surfacecolor) surfacecolor = surfacecolor.reshape(-1,3) surfacecolor = convert.sRGB_from_linearRGB(surfacecolor) fig.add_mesh3d(z=z, x=x, y=y, opacity=1.0, delaunayaxis=&#39;x&#39;, alphahull=-1, vertexcolor=surfacecolor, lighting=dict(ambient=1.0,specular=0.0,diffuse=0.0), showlegend=False) df = KBMRGCWY add_black_white_yellow_blue_plane(fig, df) camera = dict( up=dict(x=0, y=0, z=1), center=dict(x=0, y=0, z=0), eye=dict(x=0, y=-1.75, z=0.75), ) fig.update_layout(scene_camera=camera, dragmode=&#39;orbit&#39;) fig.show() . . This plane represents all the colors that can be output by the simulation algorithm. If the theory is right, then protans and deutans dichromats can always find a color on that plane that match a given color of the full gamut. Now let&#39;s do the math to actually compute the projection of any color into that plane and get the final pipeline. . Plane projection as a 3x3 matrix . Let $p = (p_l, p_m, p_s)$ be the LMS color to transform, and $n$ the normal of the plane. Our planes always go through the origin K=(0,0,0)(black), so the plane equations are just given by their normal $n = (n_l, n_m, n_s)$ as $n.p = n_l.p_l + n_m.p_m + n_s.p_s = 0$. Let&#39;s call $p&#39; = (p_l&#39;, p_m&#39;, p_s&#39;)$ the transformed point, projected on the plane. Since only the coordinate along the dichromacy axis changes, we just need to compute the missing axis coordinate and keep the other two unchanged. For example for a protan, we have $p_m&#39; = p_m$ and $p_s&#39; = p_s$, and plugging them into the plane equation we can calculate $p_l&#39;$: . $$ n_l . p_l&#39; + n_m . p_m&#39; + n_s . p_s&#39; = 0 p_l&#39; = - frac{n_m}{n_l} . p_m - frac{n_s}{n_l} . p_s $$So we just need the normal of the plane, which is given by the cross-product of two vectors on the plane. Here are the normal of the protan/deutan black-white-blue-yellow plane and the resulting $- frac{n_m}{n_l}$ and $- frac{n_s}{n_l}$ factors for a protan: . v_blue = lms_of_key(KBMRGCWY, &#39;B&#39;) # - K which is ommitted since it&#39;s zero v_yellow = lms_of_key(KBMRGCWY, &#39;Y&#39;) # - K which is ommitted since it&#39;s zero n = np.cross(v_yellow, v_blue) print (&#39;Normal (protan &amp; deutan) = &#39;, n) print (&#39;n_m / n_l = &#39;, n[1]/n[0]) print (&#39;n_s / n_l = &#39;, n[2]/n[0]) . Normal (protan &amp; deutan) = [ 0.00464048 -0.00937617 0.01129375] n_m / n_l = -2.0205178981 n_s / n_l = 2.43374588917 . These factors can be put into a matrix $H$ so that $p&#39; = H . p$: . H_protan = np.array([ [0., -n[1]/n[0], -n[2]/n[0]], [0, 1, 0], [0, 0, 1] ]) printMatrix(&#39; nProjection matrix for protan&#39;, H_protan) . Projection matrix for protan = array([[ 0. , 2.0205179 , -2.43374589], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]]) . Similarly we can get the deutan projection matrix, with $p_l&#39; = p_l$, $p_s&#39; = p_s$ and $p_m&#39; = - frac{n_l}{n_m} . p_l - frac{n_s}{n_m} . p_s$ this time: . H_deutan = np.array([ [1, 0, 0], [-n[0]/n[1], 0, -n[2]/n[1]], [0, 0, 1] ]) printMatrix(&#39; nProjection matrix for deutan&#39;, H_deutan) . Projection matrix for deutan = array([[ 1. , 0. , 0. ], [ 0.49492261, 0. , 1.20451588], [ 0. , 0. , 1. ]]) . These matrices don&#39;t exactly match the Viénot 1999 paper because we used the sRGB version of the model (convert.LMSModel_sRGB_SmithPokorny75). They would match if we used lms_model = LMSModel_Vienot1999_SmithPokorny75 instead at the beginning of the code section. . Putting it together . Since the projection is just a 3x3 linear matrix, we can combine all the matrices to transform a linear RGB point into its dichromat counterpart and then go back to linear RGB. We also need to add the non-linear from/to conversion between sRGB and linearRGB to get the final Viénot 1999 pipeline: . srgb_protan = toSRGB(linearRGB_from_LMS . H_protan . LMS_from_linearRGB . fromSRGB(srgb)) srgb_deutan = toSRGB(linearRGB_from_LMS . H_deutan . LMS_from_linearRGB . fromSRGB(srgb)) . We are almost done, we just need to deal with a last hiccup. Some LMS coordinates of the sRGB gamut might fall outside of the parallelepiped once projected onto the plane. For example if we apply the pipeline to the pure green color [0,1,0] we get: . green_protan = lms_model.linearRGB_from_LMS @ H_protan @ lms_model.LMS_from_linearRGB @ np.array([0.0, 1.0, 0.0]) green_protan . array([ 0.89111069, 0.89111069, -0.00447131]) . The blue coordinate becomes negative because green falls slightly outside of the parallelepiped once projected along the L axis onto the black-white-blue-yellow plane. Here the error is very small so it&#39;s ok to just clip the final values to [0,1]. This is the approach taken by (Simon-Liedtke &amp; Farup, 2016). . Another way if we use models where we can have larger errors is to de-saturate the color by adding a white component until all the coordinates become positive. This is what we did for the rgb_475, rgb_575, rgb_485 and rgb_660 visualization of the wavelengths. Just clipping was totally wrong for those as some had large negative values. See this page of the fourmilab for more details, it&#39;s implemented as convert.desaturate_linearRGB_to_fit_in_gamut in DaltonLens. . Now it&#39;s time to see what kind of results we can get! . def simulate_dichromacy_vienot(im, projection_matrix): color_mat = lms_model.linearRGB_from_LMS @ projection_matrix @ lms_model.LMS_from_linearRGB im_linear_rgb = convert.linearRGB_from_sRGB(convert.as_float32(im)) im_protan_linear_rgb = convert.apply_color_matrix(im_linear_rgb, color_mat) return convert.as_uint8(convert.sRGB_from_linearRGB(im_protan_linear_rgb)) import urllib.request import cv2 pngdata = urllib.request.urlopen(&#39;https://upload.wikimedia.org/wikipedia/commons/d/d7/Byrcolorwheel.png&#39;).read() # pngdata = urllib.request.urlopen(&#39;http://www.vischeck.com/images//poppies.jpg&#39;).read() im = cv2.imdecode(np.frombuffer(pngdata, dtype=np.uint8), cv2.IMREAD_COLOR) im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB) # OpenCV flips the channels by default. im_protan = simulate_dichromacy_vienot(im, H_protan) im_deutan = simulate_dichromacy_vienot(im, H_deutan) im_original = im.copy() cv2.putText(im_original, &#39;Original&#39;, (157,190), cv2.FONT_HERSHEY_COMPLEX, 0.5, (64,64,64), 1, cv2.LINE_AA) cv2.putText(im_protan, &#39;Protan (Vienot)&#39;, (125,190), cv2.FONT_HERSHEY_COMPLEX, 0.5, (64,64,64), 1, cv2.LINE_AA) cv2.putText(im_deutan, &#39;Deutan (Vienot)&#39;, (125,190), cv2.FONT_HERSHEY_COMPLEX, 0.5, (64,64,64), 1, cv2.LINE_AA) px.imshow(np.hstack([im_original, im_protan, im_deutan]), height=400).update_layout(hide_image_axes) . . What about tritanopes? . If we want a one-plane solution for tritanopes we can use the same method but using the black-white-red-cyan plane instead of the black-white-blue-yellow plane we used for protanopes and deuteranopes. As we observed before it&#39;s not a very nice fit, but let&#39;s try it anyway and we&#39;ll compare that with the Brettel 1997 method next. . v_red = lms_of_key(KBMRGCWY, &#39;R&#39;) # - K which is ommitted since it&#39;s zero v_cyan = lms_of_key(KBMRGCWY, &#39;C&#39;) # - K which is ommitted since it&#39;s zero n = np.cross(v_cyan, v_red) print (&#39;Normal (tritan) = &#39;, n) H_tritan = np.array([ [1, 0, 0], [0, 1, 0], [-n[0]/n[2], -n[1]/n[2], 0], ]) printMatrix(&#39; nProjection matrix for tritan&#39;, H_tritan) print() im_tritan = simulate_dichromacy_vienot(im, H_tritan) cv2.putText(im_tritan, &#39;Tritan (Vienot)&#39;, (125,190), cv2.FONT_HERSHEY_COMPLEX, 0.5, (64,64,64), 1, cv2.LINE_AA) px.imshow(np.hstack([im_original, im_tritan]), height=400).update_layout(hide_image_axes) . Normal (tritan) = [-0.00048455 0.00292798 -0.03960095] Projection matrix for tritan = array([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [-0.01223581, 0.07393711, 0. ]]) . Comparing Vi&#233;not 1999 and Brettel 1997 . Let&#39;s implement (Brettel &amp; Mollon, 1997) so we can compare and see whether the extra complexity is worth it. The implementation is very similar to the Viénot approach, but instead of projecting on just one plane we have to project to one of the 2 planes. The plane on which to project depends on the LMS color. The paper directly gives a simple criteria to decide, but it was not so obvious to me so I re-did the math. . Let&#39;s take the example of tritanopia to reason about this: . If the LMS color is on the &quot;same side&quot; as the 485nm point then we should project on that half-plane, otherwise on the 660nm half-plane. . | The separation is determined by the diagonal $K-E$ . | The projection is along the S axis, so we need to determine if the point is on the same side of the plane oriented along the S axis that goes through the K-E diagonal (black-equal energy). A third point on that plane is for example $K+(0,0,1) = (0,0,1)$ since $K$ is the origin. . | Now to determine the side of any point $P = (P_l,P_m,P_s)$ w.r.t to a plane, we can check the sign of the dot-product of a vector going from the plane to the point with the plane normal. . | The plane normal is given by the cross-product of two vectors on the plane: $$n = (E-K) times ((0,0,1)-K) = E times (0,0,1) = (E_m,-E_l,0)$$ . | So the dot product becomes: $P . n = P_l.E_m - P_m.E_l$. And this is positive if $P_l.E_m &gt; P_m.E_l$. The Brettel paper gives the equivalent condition $ frac{P_l}{P_m} &gt; frac{E_l}{E_m}$ since all the quantities are positive. . | . Let&#39;s start with the tritanopes for once since those are the most likely to have a significant difference. We first need to compute the 2 projection planes. . v_E = lms_of_key(KBMRGCWY, &#39;E&#39;) # - K which is omitted since it&#39;s zero v_485 = lms_of_key(KBMRGCWY, &#39;485nm&#39;) # - K which is omitted since it&#39;s zero v_660 = lms_of_key(KBMRGCWY, &#39;660nm&#39;) # - K which is omitted since it&#39;s zero n1 = np.cross(v_E, v_485) # first plane n2 = np.cross(v_E, v_660) # second plane H_tritans_brettel = [ np.array([ [1, 0, 0], [0, 1, 0], [-n1[0]/n1[2], -n1[1]/n1[2], 0]]), np.array([ [1, 0, 0], [0, 1, 0], [-n2[0]/n2[2], -n2[1]/n2[2], 0]]) ] printMatrix(&#39; nProjection matrix for tritan (485nm)&#39;, H_tritans_brettel[0]) printMatrix(&#39; nProjection matrix for tritan (660nm)&#39;, H_tritans_brettel[1]) . Projection matrix for tritan (485nm) = array([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [-0.05914768, 0.16570083, 0. ]]) Projection matrix for tritan (660nm) = array([[ 1. , 0. , 0. ], [ 0. , 1. , 0. ], [-0.00202713, 0.05209485, 0. ]]) . Now we can create the simulation function and see the results. . def projection_matrix(plane_normal, anomaly: simulate.Deficiency): n = plane_normal if anomaly == simulate.Deficiency.PROTAN: return np.array([ [0., -n[1]/n[0], -n[2]/n[0]], [0, 1, 0], [0, 0, 1] ]) if anomaly == simulate.Deficiency.DEUTAN: return np.array([ [1, 0, 0], [-n[0]/n[1], 0, -n[2]/n[1]], [0, 0, 1] ]) if anomaly == simulate.Deficiency.TRITAN: return np.array([ [1, 0, 0], [0, 1, 0], [-n[0]/n[2], -n[1]/n[2], 0] ]) return None def simulate_dichromacy_brettel(im, lms_E, lms_on_wing1, lms_on_wing2, anomaly: simulate.Deficiency): n1 = np.cross(lms_E, lms_on_wing1) # first plane n2 = np.cross(lms_E, lms_on_wing2) # second plane n_sep_plane = np.cross(lms_E, simulate.lms_confusion_axis(anomaly)) # separation plane going through the diagonal # Swap the input so that wing1 is on the positive side of the separation plane if np.dot(n_sep_plane, lms_on_wing1) &lt; 0: n1, n2 = n2, n1 lms_on_wing1, lms_on_wing2 = lms_on_wing2, lms_on_wing1 H1 = projection_matrix(n1, anomaly) H2 = projection_matrix(n2, anomaly) im_linear_rgb = convert.linearRGB_from_sRGB(convert.as_float32(im)) im_lms = convert.apply_color_matrix(im_linear_rgb, lms_model.LMS_from_linearRGB) im_H1 = convert.apply_color_matrix(im_lms, H1) im_H2 = convert.apply_color_matrix(im_lms, H2) H2_indices = np.dot(im_lms, n_sep_plane) &lt; 0 # Start with H1, then overwrite the pixels that are closer to plane 2 with im_H2 im_H = im_H1 im_H[H2_indices] = im_H2[H2_indices] im_linear_rgb = convert.apply_color_matrix(im_H, lms_model.linearRGB_from_LMS) return convert.as_uint8(convert.sRGB_from_linearRGB(im_linear_rgb)) im_tritan_brettel = simulate_dichromacy_brettel(im, lms_of_key(KBMRGCWY, &#39;E&#39;), lms_485, lms_660, simulate.Deficiency.TRITAN) cv2.putText(im_tritan_brettel, &#39;Tritan (Brettel)&#39;, (125,190), cv2.FONT_HERSHEY_COMPLEX, 0.5, (64,64,64), 1, cv2.LINE_AA) px.imshow(np.hstack([im_original, im_tritan, im_tritan_brettel])).update_layout(hide_image_axes) . . We can do the same for protans and deutans and complete the comparison. . v_E = lms_of_key(KBMRGCWY, &#39;E&#39;) # - K which is omitted since it&#39;s zero v_475 = lms_of_key(KBMRGCWY, &#39;475nm&#39;) # - K which is omitted since it&#39;s zero v_575 = lms_of_key(KBMRGCWY, &#39;575nm&#39;) # - K which is omitted since it&#39;s zero n1 = np.cross(v_E, v_475) # first plane n2 = np.cross(v_E, v_575) # second plane H_protans_brettel = [ np.array([ [0., -n1[1]/n1[0], -n1[2]/n1[0]], [0, 1, 0], [0, 0, 1]]), np.array([ [0., -n2[1]/n2[0], -n2[2]/n2[0]], [0, 1, 0], [0, 0, 1]])] H_deutans_brettel = [ np.array([ [1, 0, 0], [-n1[0]/n1[1], 0, -n1[2]/n1[1]], [0, 0, 1]]), np.array([ [1, 0, 0], [-n2[0]/n2[1], 0, -n2[2]/n2[1]], [0, 0, 1]]) ] printMatrix(&#39; nProjection matrix for protan (475nm)&#39;, H_protans_brettel[0]) printMatrix(&#39;Projection matrix for protan (575nm)&#39;, H_protans_brettel[1]) printMatrix(&#39; nProjection matrix for deutan (475nm)&#39;, H_deutans_brettel[0]) printMatrix(&#39;Projection matrix for deutan (575nm)&#39;, H_deutans_brettel[1]) im_protan_brettel = simulate_dichromacy_brettel(im, lms_E, lms_475, lms_575, simulate.Deficiency.PROTAN) cv2.putText(im_protan_brettel, &#39;Protan (Brettel)&#39;, (125,190), cv2.FONT_HERSHEY_COMPLEX, 0.5, (64,64,64), 1, cv2.LINE_AA) px.imshow(np.hstack([im_original, im_protan, im_protan_brettel]), height=400).update_layout(hide_image_axes) . . Projection matrix for protan (475nm) = array([[ 0. , 2.2611842 , -5.66553395], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]]) Projection matrix for protan (575nm) = array([[ 0. , 2.18378218, -4.05510983], [ 0. , 1. , 0. ], [ 0. , 0. , 1. ]]) Projection matrix for deutan (475nm) = array([[ 1. , 0. , 0. ], [ 0.44224615, 0. , 2.50556056], [ 0. , 0. , 1. ]]) Projection matrix for deutan (575nm) = array([[ 1. , 0. , 0. ], [ 0.45792113, 0. , 1.85692047], [ 0. , 0. , 1. ]]) . im_deutan_brettel = simulate_dichromacy_brettel(im, lms_E, lms_475, lms_575, simulate.Deficiency.DEUTAN) cv2.putText(im_deutan_brettel, &#39;Deutan (Brettel)&#39;, (125,190), cv2.FONT_HERSHEY_COMPLEX, 0.5, (64,64,64), 1, cv2.LINE_AA) px.imshow(np.hstack([im_original, im_deutan, im_deutan_brettel]), height=400).update_layout(hide_image_axes) . . For protanopia and deuteranopia the results are significantly more similar, so the more efficient Viénot approach is a good choice. It also better preserves with extreme values like pure RGB white (255,255,255) since the plane diagonal goes exactly through white and not E in the LMS space. . What about anomalous trichromacy? . Most people with CVD still have some perception with the deficient kind of cones. The Brettel 1997 and the Viénot 1999 models can be adjusted to be more progressive by not projecting all the way towards the plane. . (Flatla &amp; Gutwin, 2012) (refined for a mobile app in (MacAlpine &amp; Flatla, 2016)) propose to make a fixed step towards the plane, with the step size determined from a custom calibration. The step is actually made in the Luv color space since a fixed step there is supposed to be perceptually uniform in that space. . Another approach was proposed was (Machado, Oliveira, &amp; Fernandes, 2009), where the degree of severity comes from an amount of shift in the peak wavelength of the cone response. Dichromacy can be represented when e.g. the M-cone is shifted to align with the S-cone, effectively suppressing it. By shifting it less, various degrees of severity can be simulated. At the end of the day (missing reference) the step size is proportional to the distance between the point and the plane, while the steps are fixed in (MacAlpine &amp; Flatla, 2016). It&#39;s unclear which one is more accurate from a perception point of view. . It&#39;s also trivially possible to extend the Viénot 1999 or Brettel 1997 methods by introducing a severity factor between 0 and 1 that does a linear interpolation between the dichromat simulation and the original image (in the linear RGB space). In practice this gives pretty good results, making Brettel 1997 and Machado 2009 quite close for protanomaly and deuteranomaly. Here is an example for protanomaly (generated with the implementations of DaltonLens-Python): . . OriginalMachado 2009 (1.0 severity)Brettel 1997 (1.0 severity) . | | | . OriginalMachado 2009 (0.5 severity)Brettel 1997 (0.5 severity) . | | | . The main problem then becomes to estimate the severity factor for each individual. (Flatla &amp; Gutwin, 2012) uses a calibration method where a number of colored patterns are shown to the user with an increasing distance from the neutral gray until she can distinguish them. And that distance is then used to determine the severity factor. But we&#39;re still lacking convenient open source tools to do that, so in practice people just have to try various parameters until they can&#39;t see the difference between the original and the simulated images. . Conclusion . We&#39;ve seen how the most popular CVD simulation methods work and visualized the corresponding projection planes in the LMS space. As we discussed in our Review of Open Source Color Blindness Simulations we can&#39;t expect a perfect accuracy for the simulation. The main source of inaccuracy is the per-person variations as the severity and cone cells sensitivity can vary. So ideally we&#39;d need an individual calibration procedure and a way to inject that calibration in the model. As an intermediate step we&#39;ll show in a followup post how we can generate Ishihara-like plates for each model and degree of severity. This will let everyone self-evaluate how good the models are and what severity they have for each model. . The next step after simulation is to try to transform images to help people with CVD to process them. The most well-known approach is the daltonize algorithm from (Fidaner, Lin, &amp; Ozguven, 2005), but it&#39;s main advantage is the simplicity and code availability as it is quite rough (it was actually just a small school project!). There are a lot of more recent work in that area, but that&#39;ll also be the subject of a future post. . Bibliography . Brettel, H., &amp; Mollon, J. D. (1997). Computerized simulation of color appearance for dichromats. 14(10), 2647–2655. | Viénot, F., Brettel, H., &amp; Mollon, J. D. (1999). Digital video colourmaps for checking the legibility of displays by dichromats. Color Research &amp; Application, 24(4), 243–252. | Machado, G. M., Oliveira, M. M., &amp; Fernandes, L. A. F. (2009). A physiologically-based model for simulation of color vision deficiency. IEEE Transactions on Visualization and Computer Graphics, 15(6), 1291–1298. https://doi.org/10.1109/TVCG.2009.113 | Fidaner, O., Lin, P., &amp; Ozguven, N. (2005). Analysis of Color Blindness. | daltonize.org. (2010). Retrieved from http://www.daltonize.org | Simon-Liedtke, J. T., &amp; Farup, I. (2016). Using a Behavioral Match-to-Sample Method to Evaluate Color Vision Deficiency Simulation Methods. Journal of Imaging Science and Technology, 60(5), 504091–504099. https://doi.org/10.2352/J.ImagingSci.Technol.2016.60.5.050409 | Dietrich, J., &amp; daltonize.py. (2020). daltonize. Retrieved from https://github.com/joergdietrich | Jim, &amp; Ixora. (2021). Color Blindness Simulation Research. Retrieved from https://ixora.io/projects/colorblindness/color-blindness-simulation-research/ | Smith, V. C., &amp; Pokorny, J. (1975). Spectral sensitivity of the foveal cone photopigments between 400 and 500 nm. Vision Research, 15(2), 161–171. | Meyer, G. W., &amp; Greenberg, D. P. (1988). Color-defective vision and computer graphics displays. IEEE Computer Graphics and Applications, 8(5), 28–40. | Estévez, O. (1981). On the fundamental data-base of normal and dichromatic colour vision. Ph. D. Thesis, University of Amsterdam. | Stockman, A., &amp; Sharpe, L. T. (2000). The spectral sensitivities of the middle-and long-wavelength-sensitive cones derived from measurements in observers of known genotype. Vision Research, 40, 1711–1737. | Viénot, F., &amp; Le Rohellec, J. (2013). Colorimetry and Physiology - The LMS Specification. In Digital Color (pp. 1–28). Hoboken, NJ USA: John Wiley &amp; Sons, Inc. https://doi.org/10.1002/9781118562680.ch1 | Smith, V. C., &amp; Pokorny, J. (2003). Color Matching and Color Discrimination. In The Science of Color (pp. 103–148). Elsevier. https://doi.org/10.1016/B978-044451251-2/50004-0 | Fairchild, M. D. (2013). Color appearance models. John Wiley &amp; Sons. | Flatla, D. R., &amp; Gutwin, C. (2012). &quot;So that’s what you see&quot;: building understanding with personalized simulations of colour vision deficiency. Proceedings of the 14th International ACM SIGACCESS Conference on Computers and Accessibility, 167–174. New York, NY, USA: Association for Computing Machinery. https://doi.org/10.1145/2384916.2384946 | MacAlpine, R., &amp; Flatla, D. R. (2016). Real-Time Mobile Personalized Simulations of Impaired Colour Vision. 9. | . Appendix . Code to generate the confusion lines of the introduction . # Debug figure to visualize the confusion lines fig = px.scatter_3d(KBMRGCWY.loc[&#39;K&#39;:&#39;Y&#39;], x=&#39;L&#39;, y=&#39;M&#39;, z=&#39;S&#39;, color=&#39;colorhex&#39;, color_discrete_map=&#39;identity&#39;, text=&#39;short_name&#39;, width=800, height=800) # Add the parallelepiped lines df = KBMRGCWY.loc[[&#39;K&#39;,&#39;B&#39;,&#39;M&#39;,&#39;R&#39;, &#39;K&#39;, &#39;G&#39;, &#39;Y&#39;, &#39;W&#39;, &#39;C&#39;, &#39;G&#39;, &#39;Y&#39;, &#39;R&#39;, &#39;M&#39;, &#39;W&#39;, &#39;C&#39;, &#39;B&#39;]] fig.add_scatter3d(x=df[&#39;L&#39;], y=df[&#39;M&#39;], z=df[&#39;S&#39;], mode=&#39;lines&#39;, showlegend=False) # Add the black-white diagonal df = KBMRGCWY.loc[[&#39;K&#39;,&#39;W&#39;]] fig.add_scatter3d(x=df[&#39;L&#39;], y=df[&#39;M&#39;], z=df[&#39;S&#39;], mode=&#39;lines&#39;, showlegend=False, line=dict(width=8, dash=&#39;dash&#39;, color=&#39;gray&#39;)) # add_black_white_yellow_blue_plane(fig, KBMRGCWY) def generate_confusion_line(lms_color, anomaly, num_steps, fig): # This returns a line segment along the anomaly projection axis (L, M or S) # that passes through the input LMS color and stops at the boundaries of the # gamut (the parallelepiped). Then we can walk along that segment with small # steps to generate confusion colors. segment = geometry.lms_confusion_segment(lms_color, lms_model, anomaly) colors = [] # Ensure num_steps at the end step = (1.0 / (num_steps-1)) - 1e-5 for s in np.arange(0.0, 1.0, step): p = segment[0]*(1.0-s) + segment[1]*s colors.append (p) if fig: fig.add_scatter3d(x=[p[0]], y=[p[1]], z=[p[2]], showlegend=False, marker=dict(color=lms_model.sRGB_hexstring_from_LMS(p), line=dict(color=&#39;Black&#39;, width=1))) return colors anomaly = simulate.Deficiency.PROTAN num_steps = 7 # Generate segments that passes through a set of LMS points. To get a nice # distribution of the segment we sample them from the diagonal Black-Yellow-Blue plane U = lms_of_key(KBMRGCWY, &#39;Y&#39;) - lms_of_key(KBMRGCWY, &#39;K&#39;) V = lms_of_key(KBMRGCWY, &#39;B&#39;) - lms_of_key(KBMRGCWY, &#39;K&#39;) confusion_lines = [] # for uv_plane in itertools.product([0.1,0.25,0.5,0.75,0.9], [0.02,0.1,0.25,0.5,0.75,0.9]): for uv_plane in [(0.2,0.2), (0.5,0.5), (0.25, 0.75), (0.75, 0.25), (0.8, 0.8)]: lms_color = uv_plane @ np.array([U,V]) colors = generate_confusion_line(lms_color, anomaly, num_steps, fig) confusion_lines.append(colors) print (f&quot;# Confusion lines for {anomaly}&quot;) print (&quot;confusion_lines = [&quot;) for line in confusion_lines: print (&quot; &quot;*4 + &quot;pd.DataFrame.from_records([&quot;) lines_as_text = [] for c in line: srgb_hex = lms_model.sRGB_hexstring_from_LMS(c) L, M, S = c[0], c[1], c[2] linear_rgb = convert.apply_color_matrix(c, lms_model.linearRGB_from_LMS) linear_rgb = np.clip(linear_rgb,0.,1.0) R, G, B = linear_rgb[0], linear_rgb[1], linear_rgb[2] lines_as_text.append(&quot; &quot;*8 + f&quot;({L:.4f}, {M:.4f}, {S:.4f}, {R:.4f}, {G:.4f}, {B:.4f}, &#39;{srgb_hex}&#39;)&quot;) print (&quot;, n&quot;.join(lines_as_text) + &quot;],&quot;) print (&quot; &quot;*8 + &quot;columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]),&quot;) print(&quot;]&quot;) # Uncomment to show the confusion lines. # fig.show() confusion_matrices = [] for confusion_line in confusion_lines: confusion_matrix = np.expand_dims(np.array(confusion_line), axis=0) confusion_matrix = convert.apply_color_matrix(confusion_matrix, lms_model.linearRGB_from_LMS) confusion_matrix = convert.sRGB_from_linearRGB(confusion_matrix) confusion_matrices.append(np.clip(confusion_matrix*255.0, 0., 255.).astype(np.uint8)) fig = px.imshow(np.vstack(confusion_matrices), title=f&quot;Confusion lines for {anomaly}. The colors on each row should appear similar to a dichromat.&quot;).update_layout(hide_image_axes).update_layout(margin=None) fig.show() . . # Confusion lines for Deficiency.PROTAN confusion_lines = [ pd.DataFrame.from_records([ (0.1060, 0.0690, 0.0035, 0.0000, 0.2244, 0.2010, &#39;#00827b&#39;), (0.1268, 0.0690, 0.0035, 0.1667, 0.2041, 0.2002, &#39;#717c7b&#39;), (0.1476, 0.0690, 0.0035, 0.3333, 0.1837, 0.1993, &#39;#9c767b&#39;), (0.1684, 0.0690, 0.0035, 0.5000, 0.1633, 0.1985, &#39;#bb707b&#39;), (0.1892, 0.0690, 0.0035, 0.6666, 0.1430, 0.1977, &#39;#d5697a&#39;), (0.2101, 0.0690, 0.0035, 0.8333, 0.1226, 0.1968, &#39;#eb627a&#39;), (0.2309, 0.0690, 0.0035, 0.9999, 0.1023, 0.1960, &#39;#fe5a7a&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.2649, 0.1726, 0.0088, 0.0000, 0.5611, 0.5025, &#39;#00c5bb&#39;), (0.2858, 0.1726, 0.0088, 0.1667, 0.5407, 0.5017, &#39;#71c2bb&#39;), (0.3066, 0.1726, 0.0088, 0.3333, 0.5204, 0.5008, &#39;#9cbebb&#39;), (0.3274, 0.1726, 0.0088, 0.5000, 0.5000, 0.5000, &#39;#bbbbbb&#39;), (0.3482, 0.1726, 0.0088, 0.6666, 0.4796, 0.4992, &#39;#d5b8bb&#39;), (0.3690, 0.1726, 0.0088, 0.8333, 0.4593, 0.4983, &#39;#ebb4bb&#39;), (0.3898, 0.1726, 0.0088, 0.9999, 0.4389, 0.4975, &#39;#feb0bb&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.1505, 0.1044, 0.0120, 0.0000, 0.2805, 0.7513, &#39;#0090e0&#39;), (0.1713, 0.1044, 0.0120, 0.1667, 0.2602, 0.7504, &#39;#718be0&#39;), (0.1921, 0.1044, 0.0120, 0.3333, 0.2398, 0.7496, &#39;#9c86e0&#39;), (0.2129, 0.1044, 0.0120, 0.5000, 0.2195, 0.7487, &#39;#bb80e0&#39;), (0.2337, 0.1044, 0.0120, 0.6666, 0.1991, 0.7479, &#39;#d57be0&#39;), (0.2545, 0.1044, 0.0120, 0.8333, 0.1787, 0.7471, &#39;#eb75e0&#39;), (0.2754, 0.1044, 0.0120, 0.9999, 0.1584, 0.7462, &#39;#fe6ee0&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.3794, 0.2408, 0.0055, 0.0000, 0.8416, 0.2538, &#39;#00ec89&#39;), (0.4002, 0.2408, 0.0055, 0.1667, 0.8213, 0.2529, &#39;#71e989&#39;), (0.4211, 0.2408, 0.0055, 0.3333, 0.8009, 0.2521, &#39;#9ce789&#39;), (0.4419, 0.2408, 0.0055, 0.5000, 0.7806, 0.2513, &#39;#bbe489&#39;), (0.4627, 0.2408, 0.0055, 0.6666, 0.7602, 0.2504, &#39;#d5e189&#39;), (0.4835, 0.2408, 0.0055, 0.8333, 0.7398, 0.2496, &#39;#ebdf88&#39;), (0.5043, 0.2408, 0.0055, 0.9999, 0.7195, 0.2487, &#39;#fedc88&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), pd.DataFrame.from_records([ (0.5488, 0.2761, 0.0140, 1.0000, 0.7756, 0.7990, &#39;#fee3e6&#39;), (0.5280, 0.2761, 0.0140, 0.8333, 0.7959, 0.7998, &#39;#ebe6e7&#39;), (0.5072, 0.2761, 0.0140, 0.6667, 0.8163, 0.8007, &#39;#d5e9e7&#39;), (0.4864, 0.2761, 0.0140, 0.5000, 0.8367, 0.8015, &#39;#bbebe7&#39;), (0.4655, 0.2761, 0.0140, 0.3334, 0.8570, 0.8023, &#39;#9ceee7&#39;), (0.4447, 0.2761, 0.0140, 0.1667, 0.8774, 0.8032, &#39;#71f0e7&#39;), (0.4239, 0.2761, 0.0140, 0.0001, 0.8977, 0.8040, &#39;#00f3e7&#39;)], columns = [&#39;L&#39;, &#39;M&#39;, &#39;S&#39;, &#39;R&#39;, &#39;G&#39;, &#39;B&#39;, &#39;sRGB_hex&#39;]), ] .",
            "url": "http://daltonlens.org/understanding-cvd-simulation/",
            "relUrl": "/understanding-cvd-simulation/",
            "date": " • Oct 21, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "Review of Open Source Color Blindness Simulations",
            "content": "Introduction . Why simulate color vision deficiencies (CVD)? . Color vision deficiencies (CVD), commonly called &quot;color blindness&quot; affects ~8% of the male population and ~0.4% of the female population. Being able to accurately simulate them is important for several reasons: . Communicate about this issue and help other people understand it | Help designers choose color schemes that everyone will perceive | Create tools to enhance images and help color blind people in their daily tasks. Most correction tools start by simulating how a person with CVD would see the image, and then find some way to spread the lost information into the channels that are better perceived or playing with the light intensity to restore the contrast. | . There are many online resources to understand CVD in detail. The wikipedia page and color-blindness.com are a good start, but here are some relevant facts to understand CVD simulations: . Human color perception is achieved via cone cells in the retina. Humans with normal vision have 3 kinds of cells, sensitive to different light wavelengths. L cones capture Long-wavelength (~red), M cones capture Medium-wavelength (~green) and S cones capture Short-wavelength (~blue). Their response over the light spectrum is shown below. | . . . Most color vision deficiencies can be explained by one type of cone not working properly. Protanopes, deuteranopes and tritanopes respectively lack or have malfunctioning L, M, or S cone cells. . | CVD simulations based on physiological experiments generally consists in transforming the image to a color space where the influence of each kind of cone cells is explicit and can be decreased or removed easily. The LMS color space was designed to specifically match the human cone responses and is thus the choice of the vast majority of methods. So the typical pipeline consists in transforming the RGB image into LMS, applying the simulation there, and going back to RGB. . | . Making sense of the available models and programs . There are many methods to simulate color blindness, and we can easily find lots of open source programs to do so. However color perception theory is complex and most developers (like me!) end up copying existing algorithms without having a solid understanding of where they come from and which one is best. It is also difficult to evaluate the accuracy of the simulations, so very bad simulations can still appear reasonable to an untrained observer. . While developing DaltonLens I got frustrated by this as I was trying to decide which method I should implement. And being a mild-protan myself, I was often not very convinced by the results of existing methods as they tended to make the simulated images way too exaggerated. But for the first version I had little time and copy/pasted some code for the daltonize filters, which turned out to be quite wrong. . So I&#39;ve decided to dig further into the history of the available algorithms and try to understand where they come from and how much we can trust them. . Vocabulary notes . As it can get confusing, here is a summary of the main terms to describe CVD variants: . Dichromacy refers to one kind of cone cells fully missing. The corresponding deficiencies for each kind are called protanopia, deuteranopia and tritanopia. The color space of people with dichromacy (dichromats) is basically 2D instead of 3D. . | Anomalous trichromacy refers to having one kind of cone cells with only a partial disfunction (e.g less density or with a shifted wavelength peak). The corresponding deficiencies are called protanomaly, deuteranomaly and tritanomaly. In software simulations the degree of severity is usually encoded as a float value between 0 (no deficiency) and 1 (dichromacy). . | A protan or a protanope is a person suffering from protanopia (&quot;strong&quot; protan) or protanomaly (&quot;mild&quot; protan). Deutan/deuteranope and tritan/tritanope are defined similarly. . | . Overview of the main existing approaches . Let&#39;s start by looking at the most popular software and research papers. To complete this section I used the nice thread and software links compiled by Markku Laine. . Coblis and the HCIRN Color Blind Simulation function . A google search for &quot;color blindness simulation&quot; first returns color-blindness.com. I mentioned that website before because it has great introductory material, but it also proposes a CVD simulator, called Coblis. Being one of the oldest and easiest tool to test it has inspired lots of other software. But digging into the history of the code is interesting and shows that its accuracy is questionable, especially in the older version. . The simulator now relies on the source code of MaPePeR. It implements two different functions, one based on the &quot;Color-Matrix&quot; algorithm (Coblis v1), and one based on the &quot;HCIRN Color Blind Simulation function&quot; (Coblis v2, the default as of October 2021). . The &quot;Color-Matrix&quot; algorithm was developed by www.colorjack.com. He converted the &quot;HCIRN Color Blind Simulation function&quot; that works in the CIE-XYZ color-space into a faster matrix that directly works on RGB values (that kind of optimization mattered back then). He did so by running the full function on 3 RGB values (pure red, pure green, pure blue) to deduce the 3x3 transformation matrices. So this approach only ensures the equivalence for these 3 colors. It also ignores the non-linearity of sRGB images, which was approximately handled in the original code with a gamma function (more about sRGB in a followup post). The author himself later said that this was a one-night hack and that nobody should use it anymore in a comment on kaioa.com: . You&#39;re right, the ColorMatrix version is very simplified, and not accurate. I created that color matrix one night (http://www.colorjack.com/labs/colormatrix/) and since then it&#39;s shown up many places... I should probably take that page down before it spreads more! Anyways, it gives you an idea of what it might look like, but for the real thing... The author actually took down that page since then, but it&#39;s hard to stop the spread. . Regarding the proper &quot;HCIRN Color Blind Simulation function&quot;, the first public code was developed by Matthew Wickline and made available as a javascript Color Blindness Library. The author says in the acknowledgments that he wrote it by adapting some Java code that he got from Thomas Wolfmaier after reading his 1999 article Designing for the Color-Challenged: A Challenge. . This article explains that they implemented a method based on the seminal work of (Meyer &amp; Greenberg, 1988), which was the first to propose an algorithm to simulate CVD, in the CIE XYZ color space. However the implementation was not validated experimentally: . Has the model been validated on individuals with color vision deficiencies? Unfortunately, we have not yet been able to test the model. We did apply the model to some of the tables of the UMIST &#39;For Fun&#39; Colour Vision Test and were able to reproduce the predicted confusions. If you have some form of color vision deficiency, please have a look at the design aids described in the following sections and let us know how well the model predicts the color you see. . How accurate is the model? The model provides only a rough approximation. It includes estimates for some properties of color vision defects as well as assumptions about the hardware on which the colors are displayed. It also does not account for the reduced sensitivity to reds of individuals with protan defects. . It is worth noting that (Meyer &amp; Greenberg, 1988) did some experimental validation, where they noted that dichromats responded favorably to the simulations, despite some issues with highly saturated colors. (Viénot, Brettel, &amp; Mollon, 1999) later commented that working in the CIE XYZ color space is worse as it does not take into account the altered perception of luminosity for dichromats. . So to summarize:- The ColorMatrix algorithm that was used in the first version of Coblis was a one-night hack severely simplifying the Javascript code of Matthew Wickline, which itself was an adaptation of the Java code of Thomas Wolfmaier in 1999. The author of the ColorMatrix himself said that we should not use it and removed the code, so let&#39;s stop using that. . The code adapted by Matthew Wickline from Thomas Wolfmaier article was inspired by the Meyer and Greeberg paper which was a solid work. But the implementation itself was not carefully validated and the experimental validation in the 1988 paper was not fully convincing. So it&#39;s unclear how much we can trust it. Also worth noting that in the academic literature researchers have moved to more recent approaches. In any case that code should be adapted to modern monitors by implementing the proper sRGB transform from RGB to CIE XYZ as the original code used a generic gamma correction (there was no sRGB standard back then). . | Last, the license of the code is not super permissive, it cannot be used for commercial applications. . | . Some examples of software using the HCIRN Color Blind Simulation function or the ColorMatrix are: . Peacock (Python &amp; C++). HCIRN Color Blind Simulation function. | Colorblindly (chrome extension). Uses the ColorMatrix :-( | G&#39;MIC. Uses the ColorMatrix :-( | . Brettel &amp; Mollon 1997 . A more modern algorithm for dichromacy simulation was developed by (Brettel &amp; Mollon, 1997). Their paper has become a reference in the research community. The most famous implementation is the one of www.vischeck.com in Java. It also had an online version, but the website is now broken. Vischeck was used to generate the examples in the reference color science book (Fairchild, 2013) and generally considered as a reference. . An important note is that the research work was performed on an old (but calibrated!) CRT monitor, so implementations of this approach need to be adapted for modern LCD monitors and the sRGB standard. . There are comparatively few open source implementation of this algorithm as the follow-up (Viénot, Brettel, &amp; Mollon, 1999) paper from the same group proposed a simpler algorithm for protanopia and deuteranopia that is also more adapted to digital monitors. However it&#39;s worth noting that this newer approach does not work well for tritanopia, so the Brettel 1997 approach is still relevant in that case. . Another popular recent work from (Machado, Oliveira, &amp; Fernandes, 2009) uses Brettel 1997 as their reference and are actually very similar to it for dichromacy (by design, they tuned their parameters to match it). . Note that even if it was initially developed for full dichromacy, the approach can be adapted to simulate less severe anomalous trichromacy by either linearly interpolating between the original image and the dichromat image or by applying smaller corrections with fixed steps (Flatla &amp; Gutwin, 2012). It looks reasonable in practice, but the interpolation approach was not formally evaluated. . More examples of software using this approach: . GIMP (C): The GNU Image Manipulation Program has a nice implementation of Brettel 1997. | Color Oracle (Java, Objective C). Uses Brettel 1997 for the tritanopia mode, taken from the GIMP. The protanopia and deuteranopia modes use the cheaper Viénot 1999. | . Vi&#233;not, Brettel &amp; Mollon 1999 . (Viénot, Brettel, &amp; Mollon, 1999) builds on the Brettel 1997 paper. In a nutshell it simplifies the math and adapts it for digital displays. It has become a very popular reference, in large part thanks to the daltonize algorithm of (Fidaner, Lin, &amp; Ozguven, 2005). That daltonize algorithm aims at improving the color contrasts of a given image for a person with CVD. The first step is to simulate how the image is seen by a dichromat, and then distribute the error w.r.t the original image on the other color channels. That algorithm became very popular and got copy/pasted/adapted many times. Since it used the simulation algorithm of Viénot 1999 in the first step, this approach has become popular along the way too. . For protanopia and deuteranopia the results are reasonably similar between Viénot 1999 and Brettel 1997, so the faster one can be preferred. But again the Viénot paper is not well adapted to tritanopia. The authors themselves only mention protanopia and deuteranopia in it. . It can also be adapted for anomalous trichromacy like the Brettel 1997 approach, with the same limits about the validation. . Likewise, one challenge when implementing that algorithm is that the original paper was also using CRT monitors, and thus did not use the sRGB standard. So their RGB to XYZ matrices have to be adjusted for modern monitors, but many open source code copied the original matrices from (Fidaner, Lin, &amp; Ozguven, 2005) and are thus inaccurate. . A worse but also common issue is that the code from (Fidaner, Lin, &amp; Ozguven, 2005) actually did not include any gamma decoding of the input image, so many software just apply the matrices on the raw RGB values of the image and skip the sRGB decoding step altogether. This makes a whole range of colors look way too dark. . Some examples of open source projects implementing it: . daltonize.py (Python). Adapted to sRGB, but uses the CIECAM02 sharpened matrix for the RGB-&gt;LMS conversion. I think this is debatable for CVD simulation but we&#39;ll dive into that in a future post. . | Ixora.io (Processing). Adapted to sRGB and uses the Hunt-Pointer-Estevez matrix for RGB-&gt;LMS. . | daltonize.org (several languages). Most software listed there are adaptation of (Fidaner, Lin, &amp; Ozguven, 2005). And most forget the sRGB decoding altogether and still use the original CRT RGB-&gt;XYZ conversion. . | tsarjak/Simulate-Correct-ColorBlindness (Python). Also extends the approach to anomalous trichromacy by linearly interpolating between the original image and the dichromat image. Still uses the original RGB&lt;&gt;LMS conversion for CRT monitors. . | ChromaticVisionSimulator. Mobile app for Android. Uses a proper sRGB-&gt;XYZ conversion. Uses a linear interpolation with the original image to simulate anomalous trichromacy. . | . Machado 2009 . Even more recently (Machado, Oliveira, &amp; Fernandes, 2009) proposed an approach that supports both dichromacy and anomalous trichromacy in a principled way. They also made the nice and very welcome effort to publish easy-to-use matrices on their website and it is becoming more and more popular. . As mentioned earlier it is actually very similar to Brettel 1997 for dichromacy as they tuned their scaling parameters to match it. However it does not work very well for tritanopia as their model is to shift the peak response of the faulty kind of cone cells, and how it should be shifted is unclear for tritanopes. They also did not do any experimental validation with tritanopes. . For anomalous trichromacy the results are reasonably similar to the variant of Brettel 1997 that interpolates with the original image, but since the Machado approach is more principled it can be preferred. . Here are some examples of software using this approach: . colour-science.org (Python). Also has code to re-compute the predefined matrices. Overall a very comprehensive reference for anything color-related. . | Chromium and Mozilla used to rely on the ColorMatrix (Coblis v1) algorithm but fortunately now rely on the Machado approach. . | . So which one should we use? . Given the limits of the existing algorithms I would recommend different methods depending on the kind of deficiency: . For tritanopia the Brettel 1997 approach is still the most solid and basically only valid choice. For tritanomaly I&#39;d also recommend it with an interpolation factor with the original image, but this is more debatable. . | For protanopia and deuteranopia Viénot 1999, Brettel 1997 and Machado 2009 are solid choices, with a slight advantage for Viénot because it behaves a bit better with extreme values. For protanomaly and deuteranomaly Machado is more principled than linearly interpolating with the original image so it&#39;s probably a better choice. Compute-wise Viénot 1999 and Machado 2009 are similar (one 3x3 matrix multiplication per pixel), but Brettel 1997 is a bit more expensive (two 3x3 matrix multiplication + some ratio test). Still very cheap on modern computers though. . | Coblis V1 (ColorMatrix) should never be used. Coblis V2 may be ok for protanopia and deuteranopia (ideally after adjusting it to use sRGB instead of a generic gamma), but given the restrictive license and the lack of careful validation I would not recommend it. . | . This is the heuristic implemented by Simulator_AutoSelect in DaltonLens-Python. . More discussion and comparisons can be found in the (Simon-Liedtke &amp; Farup, 2016) paper. It includes an evaluation of the (Kotera, 2012) method, which I did not include as I haven&#39;t found open source implementations, and it performs worse than Viénot and Brettel in that study. . Also worth reading is the evaluation of (Lillo, Álvaro, &amp; Moreira, 2014), also concluding that Brettel 1997 is pretty accurate. They also evaluate Coblis (concluding that it is pretty inaccurate, but given the dates it was probably V1. So it does not allow us to conclude about Coblis V2. . Show me some images! . Let&#39;s get an idea of the output of each method. The input image covers the full RGB range. These results are for full dichromacy, so people with a mild CVD will likely see significant differences between the original and the simulated images for all models. . The images were generated using the implementation of each method in DaltonLens-Python, with the exception of Coblis V1 and V2 which respectively come from skratchdot/color-matrix and Peacock. . Overall it confirms that Coblis V1 (the ColorMatrix) is very broken. The other algorithms have some differences but fortunately still generally agree for protanopia and deuteranopia. For tritanopia Brettel 1997 is significantly different and should be more accurate as the other models were not designed to be compatible with tritanopia. . For protanopia . OriginalMachado 2009Viénot 1999 . | | | . Brettel 1997Coblis V1Coblis V2 . | | | . For deuteranopia . OriginalMachado 2009Viénot 1999 . | | | . Brettel 1997Coblis V1Coblis V2 . | | | . For tritanopia . OriginalMachado 2009Viénot 1999 . | | | . Brettel 1997Coblis V1Coblis V2 . | | | . How accurate are these simulations? . Brettel 1997, Viénot 1999 and Machado 2009 have a fairly solid theoretical background, but they still remain approximate mathematical models of the complex human perception of colors. So how good are they at simulating how a person with CVD perceives colors? Several studies have attempted to validate these experimentally. A first step is to ask a person with CVD to validate whether the original image and the simulated image look similar, which is what Brettel 1997 did. More elaborate studies compared how people with CVD and people with normal vision perform on color tests or color-related tasks. On the original images people with normal vision are expected to perform better, but when given the simulated images they should perform similarly as the people with the corresponding CVD, if the simulate was accurate. (Simon-Liedtke &amp; Farup, 2016) show that the Brettel model is pretty good at least for deuteranopes, and (Machado, Oliveira, &amp; Fernandes, 2009) showed pretty good results for protanopes and deuteranopes for their method, which is similar to the Brettel one for full dichromacy. . There are still some serious limits though, so all these models have to be taken with a grain of salt: . So far we&#39;ve mostly discussed dichromacy, where one kind of cone is entirely missing. But most people actually have anomalous trichromacy, where the deficient cones are still either present but with less density, or shifted towards another cone, limiting its discriminative power. For those the dichromat models will look too extreme as they can perceive more colors and see a difference between the original and simulated images. . | All these models are based on average observers. But there are great individual variations. For example Brettel 1997 noted that some experiments on 4 deuteranopes showed that two had a spectral peak of 558 nm for two of them, and 563nm for the other two. So ideally the parameters of the models would need to get adjusted for each person. . | These models assumed that only the lowest level of color perception is affected, and ignore the plasticity of the brain that can potentially adapt and change the color perception at higher levels. These simulations do not model anything like that. . | The validation experiments are generally made on very small population, rarely more than 10 people. And tritanopes are basically never evaluated since they are very rare and hard to find. . | Most people will look at these simulations on an uncalibrated computer screen in a room with some kind of background illumination. Without a proper calibration of the monitor the stimuli that corresponds to each sRGB value will be inaccurate, and the background illumination may be far from the expected D65 (normal outdoor). Also the brightness, contrast and color balance settings of the monitor can significantly change the color appearance. . | (Meyer &amp; Greenberg, 1988) noted that the size of the field of view can affect the severity of an individual&#39;s deficiency. They refer to (Pokorny &amp; Smith, 1982) that observed how the severity can decrease as the field of view increases. This explains why colors are harder to identify for a person with CVD on small objects like LEDs, but easier on large bright objects. Ideally the simulations should take that into account and preserve more of the original color on large objects. . | . Conclusion . So the good news is that there are quite a few solutions to simulate CVDs. The bad news is there is still a lot of outdated code out, and even for well-intentioned developers it&#39;s quite hard to evaluate whether the output of their simulation is correct or not, so I hope that this article can help. . A second issue is that the methods that are easy to implement are generic and were developed from experimental data collected on average observers (and a long time ago!). We&#39;re still lacking a great practical way to model individual color vision deficiency profiles and feed that into a simulator. The work of (Flatla &amp; Gutwin, 2012) and (MacAlpine &amp; Flatla, 2016) goes in that direction, but as far as I know there is no open source code for it. . There are also other research work that have remained more confidential so far like (Capilla, Díez-Ajenjo, Luque, &amp; Malo, 2004). While interesting, the main problem here again is that no large-scale validation was performed, so it&#39;s hard to know which one is better. That group also did share some Matlab code, but it hasn&#39;t been maintained and can&#39;t be run without a Matlab runtime from 2011. . This review did not dive into how these methods actually work, we&#39;ll do that in an upcoming post. . Bibliography . Meyer, G. W., &amp; Greenberg, D. P. (1988). Color-defective vision and computer graphics displays. IEEE Computer Graphics and Applications, 8(5), 28–40. | Viénot, F., Brettel, H., &amp; Mollon, J. D. (1999). Digital video colourmaps for checking the legibility of displays by dichromats. Color Research &amp; Application, 24(4), 243–252. | Brettel, H., &amp; Mollon, J. D. (1997). Computerized simulation of color appearance for dichromats. 14(10), 2647–2655. | Fairchild, M. D. (2013). Color appearance models. John Wiley &amp; Sons. | Machado, G. M., Oliveira, M. M., &amp; Fernandes, L. A. F. (2009). A physiologically-based model for simulation of color vision deficiency. IEEE Transactions on Visualization and Computer Graphics, 15(6), 1291–1298. https://doi.org/10.1109/TVCG.2009.113 | Flatla, D. R., &amp; Gutwin, C. (2012). &quot;So that’s what you see&quot;: building understanding with personalized simulations of colour vision deficiency. Proceedings of the 14th International ACM SIGACCESS Conference on Computers and Accessibility, 167–174. New York, NY, USA: Association for Computing Machinery. https://doi.org/10.1145/2384916.2384946 | Fidaner, O., Lin, P., &amp; Ozguven, N. (2005). Analysis of Color Blindness. | Simon-Liedtke, J. T., &amp; Farup, I. (2016). Using a Behavioral Match-to-Sample Method to Evaluate Color Vision Deficiency Simulation Methods. Journal of Imaging Science and Technology, 60(5), 504091–504099. https://doi.org/10.2352/J.ImagingSci.Technol.2016.60.5.050409 | Kotera, H. (2012). Optimal daltonization by spectral shift for dichromatic vision. Color and Imaging Conference, 2012, 302–308. Society for Imaging Science and Technology. | Lillo, J., Álvaro, L., &amp; Moreira, H. (2014). An experimental method for the assessment of color simulation tools. Journal of Vision, 14(8), 15. https://doi.org/10.1167/14.8.15 | Pokorny, J., &amp; Smith, V. C. (1982). New observations concerning red–green color defects. Color Research &amp; Application, 7(2), 159–164. | MacAlpine, R., &amp; Flatla, D. R. (2016). Real-Time Mobile Personalized Simulations of Impaired Colour Vision. 9. | Capilla, P., Díez-Ajenjo, M. A., Luque, M. J., &amp; Malo, J. (2004). Corresponding-pair procedure: a new approach to simulation of dichromatic color perception. Journal of the Optical Society of America. A, Optics, Image Science, and Vision, 21(2), 176–186. https://doi.org/10.1364/josaa.21.000176 | .",
            "url": "http://daltonlens.org/opensource-cvd-simulation/",
            "relUrl": "/opensource-cvd-simulation/",
            "date": " • Oct 19, 2021"
        }
        
    
  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page7": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "http://daltonlens.org/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

  
  

}